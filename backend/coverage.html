
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yamirghofran/briefbot/internal/handlers/daily_digest.go (94.2%)</option>
				
				<option value="file1">github.com/yamirghofran/briefbot/internal/handlers/handlers.go (2.0%)</option>
				
				<option value="file2">github.com/yamirghofran/briefbot/internal/handlers/items.go (97.6%)</option>
				
				<option value="file3">github.com/yamirghofran/briefbot/internal/handlers/podcast.go (77.0%)</option>
				
				<option value="file4">github.com/yamirghofran/briefbot/internal/handlers/routes.go (0.0%)</option>
				
				<option value="file5">github.com/yamirghofran/briefbot/internal/handlers/sse.go (0.0%)</option>
				
				<option value="file6">github.com/yamirghofran/briefbot/internal/handlers/users.go (89.5%)</option>
				
				<option value="file7">github.com/yamirghofran/briefbot/internal/metrics/metrics.go (100.0%)</option>
				
				<option value="file8">github.com/yamirghofran/briefbot/internal/middleware/prometheus.go (100.0%)</option>
				
				<option value="file9">github.com/yamirghofran/briefbot/internal/services/ai.go (61.4%)</option>
				
				<option value="file10">github.com/yamirghofran/briefbot/internal/services/digest.go (81.2%)</option>
				
				<option value="file11">github.com/yamirghofran/briefbot/internal/services/email.go (82.8%)</option>
				
				<option value="file12">github.com/yamirghofran/briefbot/internal/services/items.go (83.1%)</option>
				
				<option value="file13">github.com/yamirghofran/briefbot/internal/services/jobqueue.go (81.8%)</option>
				
				<option value="file14">github.com/yamirghofran/briefbot/internal/services/podcast.go (34.7%)</option>
				
				<option value="file15">github.com/yamirghofran/briefbot/internal/services/r2.go (35.1%)</option>
				
				<option value="file16">github.com/yamirghofran/briefbot/internal/services/scraping.go (88.9%)</option>
				
				<option value="file17">github.com/yamirghofran/briefbot/internal/services/speech.go (63.6%)</option>
				
				<option value="file18">github.com/yamirghofran/briefbot/internal/services/sse.go (89.8%)</option>
				
				<option value="file19">github.com/yamirghofran/briefbot/internal/services/users.go (85.7%)</option>
				
				<option value="file20">github.com/yamirghofran/briefbot/internal/services/worker.go (90.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handlers

import (
        "context"
        "log"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

// TriggerDailyDigest godoc
// @Summary      Trigger daily digest for all users
// @Description  Manually trigger the daily digest email sending process for all users
// @Tags         digest
// @Accept       json
// @Produce      json
// @Success      200  {object}  MessageResponse
// @Failure      500  {object}  ErrorResponse
// @Failure      503  {object}  ErrorResponse
// @Router       /digest/trigger [post]
func (h *Handler) TriggerDailyDigest(c *gin.Context) <span class="cov8" title="1">{
        if h.digestService == nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Digest service not available"})
                return
        }</span>

        <span class="cov8" title="1">ctx := c.Request.Context()

        // Send daily digest to all users
        if err := h.digestService.SendDailyDigest(ctx); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to send daily digest: " + err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Daily digest sent successfully to all users"})</span>
}

// TriggerDailyDigestForUser godoc
// @Summary      Trigger daily digest for specific user
// @Description  Manually trigger the daily digest email sending process for a specific user
// @Tags         digest
// @Accept       json
// @Produce      json
// @Param        userID  path      int  true  "User ID"
// @Success      200     {object}  MessageResponse
// @Failure      400     {object}  ErrorResponse
// @Failure      500     {object}  ErrorResponse
// @Failure      503     {object}  ErrorResponse
// @Router       /digest/trigger/user/{userID} [post]
func (h *Handler) TriggerDailyDigestForUser(c *gin.Context) <span class="cov8" title="1">{
        if h.digestService == nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Digest service not available"})
                return
        }</span>

        <span class="cov8" title="1">userID, err := strconv.Atoi(c.Param("userID"))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        <span class="cov8" title="1">ctx := c.Request.Context()

        // Get items first to check if there are any
        items, err := h.digestService.GetDailyDigestItemsForUser(ctx, int32(userID))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get daily digest items"})
                return
        }</span>

        // If no items, return a friendly message
        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov8" title="1">{
                c.JSON(http.StatusOK, gin.H{"message": "No unread items from previous day for this user"})
                return
        }</span>

        // Send the daily digest for this user
        <span class="cov8" title="1">if err := h.digestService.SendDailyDigestForUser(ctx, int32(userID)); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to send daily digest: " + err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Daily digest sent successfully to user"})</span>
}

// TriggerIntegratedDigest godoc
// @Summary      Trigger integrated digest for all users
// @Description  Manually trigger the integrated digest (podcast generation + email) process for all users
// @Tags         digest
// @Accept       json
// @Produce      json
// @Success      202  {object}  MessageResponse
// @Failure      503  {object}  ErrorResponse
// @Router       /digest/trigger/integrated [post]
func (h *Handler) TriggerIntegratedDigest(c *gin.Context) <span class="cov8" title="1">{
        if h.digestService == nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Digest service not available"})
                return
        }</span>

        // Start processing in background and return immediately
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                ctx := context.Background() // Use background context for async processing
                if err := h.digestService.SendIntegratedDigest(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Background integrated digest failed: %v", err)
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("Background integrated digest completed successfully")
                }</span>
        }()

        <span class="cov8" title="1">c.JSON(http.StatusAccepted, gin.H{"message": "Integrated digest processing started in background"})</span>
}

// TriggerIntegratedDigestForUser godoc
// @Summary      Trigger integrated digest for specific user
// @Description  Manually trigger the integrated digest (podcast generation + email) for a specific user
// @Tags         digest
// @Accept       json
// @Produce      json
// @Param        userID  path      int  true  "User ID"
// @Success      202     {object}  MessageResponse
// @Failure      400     {object}  ErrorResponse
// @Failure      503     {object}  ErrorResponse
// @Router       /digest/trigger/integrated/user/{userID} [post]
func (h *Handler) TriggerIntegratedDigestForUser(c *gin.Context) <span class="cov8" title="1">{
        if h.digestService == nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Digest service not available"})
                return
        }</span>

        <span class="cov8" title="1">userID, err := strconv.Atoi(c.Param("userID"))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        // Start processing in background and return immediately
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                ctx := context.Background() // Use background context for async processing
                result, err := h.digestService.SendIntegratedDigestForUser(ctx, int32(userID))
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Background integrated digest failed for user %d: %v", userID, err)
                }</span> else<span class="cov8" title="1"> if result.ItemsCount == 0 </span><span class="cov0" title="0">{
                        log.Printf("No items to process for user %d", userID)
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("Background integrated digest completed for user %d: emailSent=%v, podcastGenerated=%v",
                                userID, result.EmailSent, result.PodcastURL != nil)
                }</span>
        }()

        <span class="cov8" title="1">c.JSON(http.StatusAccepted, gin.H{"message": "Integrated digest processing started for user", "userID": userID})</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "github.com/yamirghofran/briefbot/internal/services"
)

type Handler struct {
        userService    services.UserService
        itemService    services.ItemService
        digestService  services.DigestService
        podcastService services.PodcastService
        sseManager     *services.SSEManager
}

func NewHandler(userService services.UserService, itemService services.ItemService, digestService services.DigestService, podcastService services.PodcastService, sseManager *services.SSEManager) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                userService:    userService,
                itemService:    itemService,
                digestService:  digestService,
                podcastService: podcastService,
                sseManager:     sseManager,
        }
}</span>

// Code smell Improvement
// Problem: The Handler struct depends on 5 different services and handles routing for multiple domains (users, items, podcasts, digests). This violates SRP as it has too many reasons to change.
// The solution is to split into separate handlers

// type UserHandler struct {
//     userService services.UserService
// }
// type ItemHandler struct {
//     itemService services.ItemService
//     sseManager  *services.SSEManager
// }
// type PodcastHandler struct {
//     podcastService services.PodcastService
//     sseManager     *services.SSEManager
// }
// type DigestHandler struct {
//     digestService services.DigestService
// }

func (h *Handler) Health(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(200, gin.H{"status": "up"})
}</span>

func (h *Handler) SetupRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Health check endpoint
        router.GET("/health", h.Health)

        // User routes
        userGroup := router.Group("/users")
        </span><span class="cov0" title="0">{
                userGroup.GET("", h.ListUsers)
                userGroup.POST("", h.CreateUser)
                userGroup.GET("/:id", h.GetUser)
                userGroup.GET("/email/:email", h.GetUserByEmail)
                userGroup.PUT("/:id", h.UpdateUser)
                userGroup.DELETE("/:id", h.DeleteUser)
        }</span>

        // Item routes
        <span class="cov0" title="0">itemGroup := router.Group("/items")
        </span><span class="cov0" title="0">{
                itemGroup.POST("", h.CreateItem)
                itemGroup.GET("/:id", h.GetItem)
                itemGroup.GET("/:id/status", h.GetItemProcessingStatus)
                itemGroup.GET("/status", h.GetItemsByProcessingStatus)
                itemGroup.GET("/user/:userID", h.GetItemsByUser)
                itemGroup.GET("/user/:userID/unread", h.GetUnreadItemsByUser)
                itemGroup.GET("/user/:userID/stream", h.StreamItemUpdates) // SSE endpoint
                itemGroup.PUT("/:id", h.UpdateItem)
                itemGroup.PATCH("/:id", h.PatchItem)
                itemGroup.PATCH("/:id/read", h.MarkItemAsRead)
                itemGroup.PATCH("/:id/toggle-read", h.ToggleItemReadStatus)
                itemGroup.DELETE("/:id", h.DeleteItem)
        }</span>

        // Podcast routes
        <span class="cov0" title="0">podcastHandler := NewPodcastHandler(h.podcastService)
        podcastHandler.SetSSEManager(h.sseManager)
        podcastGroup := router.Group("/podcasts")
        </span><span class="cov0" title="0">{
                // Podcast creation
                podcastGroup.POST("", podcastHandler.CreatePodcast)
                podcastGroup.POST("/from-item", podcastHandler.CreatePodcastFromSingleItem)

                // Podcast retrieval
                podcastGroup.GET("/:id", podcastHandler.GetPodcast)
                podcastGroup.GET("/:id/status", podcastHandler.GetPodcastProcessingStatus)
                podcastGroup.GET("/user/:userID", podcastHandler.GetPodcastsByUser)
                podcastGroup.GET("/user/:userID/stream", podcastHandler.StreamPodcastUpdates) // SSE endpoint
                podcastGroup.GET("/status/:status", podcastHandler.GetPodcastsByStatus)
                podcastGroup.GET("/pending", podcastHandler.GetPendingPodcasts)

                // Podcast items management
                podcastGroup.GET("/:id/items", podcastHandler.GetPodcastItems)
                podcastGroup.POST("/:id/items", podcastHandler.AddItemToPodcast)
                podcastGroup.DELETE("/:id/items/:itemID", podcastHandler.RemoveItemFromPodcast)

                // Podcast audio
                podcastGroup.GET("/:id/audio", podcastHandler.GetPodcastAudio)
                podcastGroup.GET("/:id/upload-url", podcastHandler.GeneratePodcastUploadURL)

                // Podcast management
                podcastGroup.PUT("/:id", podcastHandler.UpdatePodcast)
                podcastGroup.DELETE("/:id", podcastHandler.DeletePodcast)
        }</span>

        // Digest routes (unified - handles both regular and integrated digests)
        <span class="cov0" title="0">digestGroup := router.Group("/digest")
        </span><span class="cov0" title="0">{
                digestGroup.POST("/trigger", h.TriggerDailyDigest)
                digestGroup.POST("/trigger/user/:userID", h.TriggerDailyDigestForUser)
                digestGroup.POST("/trigger/integrated", h.TriggerIntegratedDigest)
                digestGroup.POST("/trigger/integrated/user/:userID", h.TriggerIntegratedDigestForUser)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

// CreateItem godoc
// @Summary      Create a new content item
// @Description  Create a new content item from URL with async processing
// @Tags         items
// @Accept       json
// @Produce      json
// @Param        item  body      CreateItemRequest  true  "Item creation request"
// @Success      201   {object}  CreateItemResponse
// @Failure      400   {object}  ErrorResponse
// @Failure      500   {object}  ErrorResponse
// @Router       /items [post]
func (h *Handler) CreateItem(c *gin.Context) <span class="cov8" title="1">{
        var req CreateItemRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Use async creation - just save the URL and return immediately
        <span class="cov8" title="1">item, err := h.itemService.CreateItemAsync(c.Request.Context(), *req.UserID, *req.URL)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // Return the item with pending status
        <span class="cov8" title="1">c.JSON(http.StatusCreated, gin.H{
                "item":              item,
                "message":           "Item created successfully and will be processed in the background",
                "processing_status": item.ProcessingStatus,
        })</span>
}

// GetItem godoc
// @Summary      Get an item by ID
// @Description  Retrieve a content item's information by its ID
// @Tags         items
// @Produce      json
// @Param        id   path      int  true  "Item ID"
// @Success      200  {object}  github_com_yamirghofran_briefbot_internal_db.Item
// @Failure      400  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /items/{id} [get]
func (h *Handler) GetItem(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid item ID"})
                return
        }</span>

        <span class="cov8" title="1">item, err := h.itemService.GetItem(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, item)</span>
}

// GetItemsByUser godoc
// @Summary      Get items by user
// @Description  Retrieve all content items for a specific user
// @Tags         items
// @Produce      json
// @Param        userID  path      int  true  "User ID"
// @Success      200     {array}   github_com_yamirghofran_briefbot_internal_db.Item
// @Failure      400     {object}  ErrorResponse
// @Failure      500     {object}  ErrorResponse
// @Router       /items/user/{userID} [get]
func (h *Handler) GetItemsByUser(c *gin.Context) <span class="cov8" title="1">{
        userIDStr := c.Param("userID")
        userID, err := strconv.ParseInt(userIDStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        <span class="cov8" title="1">userID32 := int32(userID)
        items, err := h.itemService.GetItemsByUser(c.Request.Context(), &amp;userID32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, items)</span>
}

// GetUnreadItemsByUser godoc
// @Summary      Get unread items by user
// @Description  Retrieve all unread content items for a specific user
// @Tags         items
// @Produce      json
// @Param        userID  path      int  true  "User ID"
// @Success      200     {array}   github_com_yamirghofran_briefbot_internal_db.Item
// @Failure      400     {object}  ErrorResponse
// @Failure      500     {object}  ErrorResponse
// @Router       /items/user/{userID}/unread [get]
func (h *Handler) GetUnreadItemsByUser(c *gin.Context) <span class="cov8" title="1">{
        userIDStr := c.Param("userID")
        userID, err := strconv.ParseInt(userIDStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        <span class="cov8" title="1">userID32 := int32(userID)
        items, err := h.itemService.GetUnreadItemsByUser(c.Request.Context(), &amp;userID32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, items)</span>
}

// UpdateItem godoc
// @Summary      Update an item
// @Description  Update a content item's information
// @Tags         items
// @Accept       json
// @Produce      json
// @Param        id    path      int                 true  "Item ID"
// @Param        item  body      UpdateItemRequest   true  "Item update request"
// @Success      200   {object}  MessageResponse
// @Failure      400   {object}  ErrorResponse
// @Failure      500   {object}  ErrorResponse
// @Router       /items/{id} [put]
func (h *Handler) UpdateItem(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid item ID"})
                return
        }</span>

        <span class="cov8" title="1">var req UpdateItemRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err = h.itemService.UpdateItem(c.Request.Context(), int32(id), req.Title, req.URL, req.TextContent, req.Summary, req.Type, req.Platform, req.Tags, req.Authors, req.IsRead)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Item updated successfully"})</span>
}

// MarkItemAsRead godoc
// @Summary      Mark item as read
// @Description  Mark a content item as read
// @Tags         items
// @Produce      json
// @Param        id   path      int  true  "Item ID"
// @Success      200  {object}  github_com_yamirghofran_briefbot_internal_db.Item
// @Failure      400  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /items/{id}/read [patch]
func (h *Handler) MarkItemAsRead(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid item ID"})
                return
        }</span>

        <span class="cov8" title="1">err = h.itemService.MarkItemAsRead(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // Return the updated item
        <span class="cov8" title="1">item, err := h.itemService.GetItem(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, item)</span>
}

// ToggleItemReadStatus godoc
// @Summary      Toggle item read status
// @Description  Toggle a content item's read/unread status
// @Tags         items
// @Produce      json
// @Param        id   path      int  true  "Item ID"
// @Success      200  {object}  github_com_yamirghofran_briefbot_internal_db.Item
// @Failure      400  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /items/{id}/toggle-read [patch]
func (h *Handler) ToggleItemReadStatus(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid item ID"})
                return
        }</span>

        <span class="cov8" title="1">item, err := h.itemService.ToggleItemReadStatus(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, item)</span>
}

// PatchItem godoc
// @Summary      Patch an item
// @Description  Partially update a content item's information
// @Tags         items
// @Accept       json
// @Produce      json
// @Param        id    path      int                true  "Item ID"
// @Param        item  body      PatchItemRequest   true  "Item patch request"
// @Success      200   {object}  github_com_yamirghofran_briefbot_internal_db.Item
// @Failure      400   {object}  ErrorResponse
// @Failure      500   {object}  ErrorResponse
// @Router       /items/{id} [patch]
func (h *Handler) PatchItem(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid item ID"})
                return
        }</span>

        <span class="cov8" title="1">var req PatchItemRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">item, err := h.itemService.PatchItem(c.Request.Context(), int32(id), req.Title, req.Summary, req.Tags, req.Authors)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, item)</span>
}

// DeleteItem godoc
// @Summary      Delete an item
// @Description  Delete a content item from the system
// @Tags         items
// @Produce      json
// @Param        id   path      int  true  "Item ID"
// @Success      200  {object}  MessageResponse
// @Failure      400  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /items/{id} [delete]
func (h *Handler) DeleteItem(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid item ID"})
                return
        }</span>

        <span class="cov8" title="1">err = h.itemService.DeleteItem(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Item deleted successfully"})</span>
}

// GetItemProcessingStatus godoc
// @Summary      Get item processing status
// @Description  Retrieve the processing status of a content item
// @Tags         items
// @Produce      json
// @Param        id   path      int  true  "Item ID"
// @Success      200  {object}  ItemProcessingStatusResponse
// @Failure      400  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /items/{id}/status [get]
func (h *Handler) GetItemProcessingStatus(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid item ID"})
                return
        }</span>

        <span class="cov8" title="1">status, err := h.itemService.GetItemProcessingStatus(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "item_id":           status.Item.ID,
                "processing_status": status.Item.ProcessingStatus,
                "is_processing":     status.IsProcessing,
                "is_completed":      status.IsCompleted,
                "is_failed":         status.IsFailed,
                "processing_error":  status.ProcessingError,
        })</span>
}

// GetItemsByProcessingStatus godoc
// @Summary      Get items by processing status
// @Description  Retrieve content items filtered by their processing status
// @Tags         items
// @Produce      json
// @Param        status  query     string  false  "Processing status (pending, processing, completed, failed)"  default(pending)
// @Success      200     {object}  ItemsByStatusResponse
// @Failure      400     {object}  ErrorResponse
// @Failure      500     {object}  ErrorResponse
// @Router       /items/status [get]
func (h *Handler) GetItemsByProcessingStatus(c *gin.Context) <span class="cov8" title="1">{
        status := c.Query("status")
        if status == "" </span><span class="cov0" title="0">{
                status = "pending"
        }</span>

        // Validate status
        <span class="cov8" title="1">validStatuses := map[string]bool{
                "pending":    true,
                "processing": true,
                "completed":  true,
                "failed":     true,
        }

        if !validStatuses[status] </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid status. Must be one of: pending, processing, completed, failed"})
                return
        }</span>

        <span class="cov8" title="1">items, err := h.itemService.GetItemsByProcessingStatus(c.Request.Context(), &amp;status)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "status": status,
                "items":  items,
                "count":  len(items),
        })</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "fmt"
        "log"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/yamirghofran/briefbot/internal/services"
)

// PodcastHandler handles podcast-related HTTP requests
type PodcastHandler struct {
        podcastService services.PodcastService
        sseManager     *services.SSEManager
}

// NewPodcastHandler creates a new podcast handler
func NewPodcastHandler(podcastService services.PodcastService) *PodcastHandler <span class="cov8" title="1">{
        return &amp;PodcastHandler{
                podcastService: podcastService,
                sseManager:     nil, // Will be set via SetSSEManager
        }
}</span>

// SetSSEManager sets the SSE manager for the podcast handler
func (h *PodcastHandler) SetSSEManager(sseManager *services.SSEManager) <span class="cov0" title="0">{
        h.sseManager = sseManager
}</span>

// CreatePodcast godoc
// @Summary      Create a new podcast
// @Description  Generate a podcast from multiple content items
// @Tags         podcasts
// @Accept       json
// @Produce      json
// @Param        podcast  body      CreatePodcastRequest  true  "Podcast creation request"
// @Success      201      {object}  CreatePodcastResponse
// @Failure      400      {object}  ErrorResponse
// @Failure      500      {object}  ErrorResponse
// @Router       /podcasts [post]
func (h *PodcastHandler) CreatePodcast(c *gin.Context) <span class="cov8" title="1">{
        var req CreatePodcastRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Create podcast from items
        <span class="cov8" title="1">podcast, err := h.podcastService.CreatePodcastFromItems(c.Request.Context(), req.UserID, req.Title, req.Description, req.ItemIDs)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, gin.H{
                "podcast":           podcast,
                "message":           "Podcast created successfully and will be processed in the background",
                "processing_status": podcast.Status,
        })</span>
}

// CreatePodcastFromSingleItem godoc
// @Summary      Create podcast from single item
// @Description  Generate a podcast from a single content item
// @Tags         podcasts
// @Accept       json
// @Produce      json
// @Param        podcast  body      CreatePodcastFromItemRequest  true  "Podcast from item request"
// @Success      201      {object}  CreatePodcastResponse
// @Failure      400      {object}  ErrorResponse
// @Failure      500      {object}  ErrorResponse
// @Router       /podcasts/from-item [post]
func (h *PodcastHandler) CreatePodcastFromSingleItem(c *gin.Context) <span class="cov8" title="1">{
        var req CreatePodcastFromItemRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Create podcast from single item
        <span class="cov8" title="1">podcast, err := h.podcastService.CreatePodcastFromSingleItem(c.Request.Context(), req.UserID, req.ItemID)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, gin.H{
                "podcast":           podcast,
                "message":           "Podcast created successfully from single item and will be processed in the background",
                "processing_status": podcast.Status,
        })</span>
}

// GetPodcast godoc
// @Summary      Get a podcast by ID
// @Description  Retrieve a podcast's information by its ID
// @Tags         podcasts
// @Produce      json
// @Param        id   path      int  true  "Podcast ID"
// @Success      200  {object}  github_com_yamirghofran_briefbot_internal_db.Podcast
// @Failure      400  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /podcasts/{id} [get]
func (h *PodcastHandler) GetPodcast(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid podcast ID"})
                return
        }</span>

        <span class="cov8" title="1">podcast, err := h.podcastService.GetPodcast(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, podcast)</span>
}

// GetPodcastsByUser godoc
// @Summary      Get podcasts by user
// @Description  Retrieve all podcasts for a specific user
// @Tags         podcasts
// @Produce      json
// @Param        userID  path      int  true  "User ID"
// @Success      200     {object}  PodcastsResponse
// @Failure      400     {object}  ErrorResponse
// @Failure      500     {object}  ErrorResponse
// @Router       /podcasts/user/{userID} [get]
func (h *PodcastHandler) GetPodcastsByUser(c *gin.Context) <span class="cov8" title="1">{
        userIDStr := c.Param("userID")
        userID, err := strconv.ParseInt(userIDStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        <span class="cov8" title="1">podcasts, err := h.podcastService.GetPodcastsByUser(c.Request.Context(), int32(userID))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "podcasts": podcasts,
                "count":    len(podcasts),
        })</span>
}

// GetPodcastsByStatus godoc
// @Summary      Get podcasts by status
// @Description  Retrieve podcasts filtered by their processing status
// @Tags         podcasts
// @Produce      json
// @Param        status  path      string  true  "Podcast status (pending, writing, generating, completed, failed)"
// @Success      200     {object}  PodcastsResponse
// @Failure      400     {object}  ErrorResponse
// @Failure      500     {object}  ErrorResponse
// @Router       /podcasts/status/{status} [get]
func (h *PodcastHandler) GetPodcastsByStatus(c *gin.Context) <span class="cov8" title="1">{
        status := c.Param("status")

        // Validate status
        validStatuses := []string{"pending", "writing", "generating", "completed", "failed"}
        isValid := false
        for _, validStatus := range validStatuses </span><span class="cov8" title="1">{
                if status == validStatus </span><span class="cov8" title="1">{
                        isValid = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !isValid </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid status. Must be one of: pending, writing, generating, completed, failed"})
                return
        }</span>

        <span class="cov8" title="1">podcasts, err := h.podcastService.GetPodcastsByStatus(c.Request.Context(), services.PodcastStatus(status))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "podcasts": podcasts,
                "count":    len(podcasts),
        })</span>
}

// GetPendingPodcasts godoc
// @Summary      Get pending podcasts
// @Description  Retrieve pending podcasts awaiting processing
// @Tags         podcasts
// @Produce      json
// @Param        limit  query     int  false  "Maximum number of podcasts to return"  default(10)
// @Success      200    {object}  PodcastsResponse
// @Failure      400    {object}  ErrorResponse
// @Failure      500    {object}  ErrorResponse
// @Router       /podcasts/pending [get]
func (h *PodcastHandler) GetPendingPodcasts(c *gin.Context) <span class="cov8" title="1">{
        limitStr := c.DefaultQuery("limit", "10")
        limit, err := strconv.ParseInt(limitStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid limit"})
                return
        }</span>

        <span class="cov8" title="1">podcasts, err := h.podcastService.GetPendingPodcasts(c.Request.Context(), int32(limit))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "podcasts": podcasts,
                "count":    len(podcasts),
        })</span>
}

// GetPodcastItems godoc
// @Summary      Get podcast items
// @Description  Retrieve all content items in a podcast
// @Tags         podcasts
// @Produce      json
// @Param        id   path      int  true  "Podcast ID"
// @Success      200  {object}  PodcastItemsResponse
// @Failure      400  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /podcasts/{id}/items [get]
func (h *PodcastHandler) GetPodcastItems(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid podcast ID"})
                return
        }</span>

        <span class="cov8" title="1">items, err := h.podcastService.GetPodcastItems(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "items": items,
                "count": len(items),
        })</span>
}

// GetPodcastAudio godoc
// @Summary      Get podcast audio
// @Description  Retrieve the audio URL for a completed podcast
// @Tags         podcasts
// @Produce      json
// @Param        id   path      int  true  "Podcast ID"
// @Success      200  {object}  PodcastAudioResponse
// @Failure      404  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /podcasts/{id}/audio [get]
func (h *PodcastHandler) GetPodcastAudio(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid podcast ID"})
                return
        }</span>

        // Check if podcast has audio
        <span class="cov8" title="1">hasAudio, err := h.podcastService.HasPodcastAudio(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if !hasAudio </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Podcast audio not available"})
                return
        }</span>

        // Get the podcast to retrieve the audio URL
        <span class="cov8" title="1">podcast, err := h.podcastService.GetPodcast(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if podcast.AudioUrl == nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Podcast audio URL not found"})
                return
        }</span>

        // Return the audio URL for client to download/stream
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "audio_url": *podcast.AudioUrl,
                "duration":  podcast.DurationSeconds,
                "message":   "Audio available at the provided URL",
        })</span>
}

// GeneratePodcastUploadURL godoc
// @Summary      Generate podcast upload URL
// @Description  Generate a presigned URL for uploading podcast audio to R2 storage
// @Tags         podcasts
// @Produce      json
// @Param        id   path      int  true  "Podcast ID"
// @Success      200  {object}  PodcastUploadInfo
// @Failure      400  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /podcasts/{id}/upload-url [get]
func (h *PodcastHandler) GeneratePodcastUploadURL(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid podcast ID"})
                return
        }</span>

        <span class="cov8" title="1">uploadInfo, err := h.podcastService.GeneratePodcastUploadURL(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, uploadInfo)</span>
}

// AddItemToPodcast godoc
// @Summary      Add item to podcast
// @Description  Add a content item to an existing podcast
// @Tags         podcasts
// @Accept       json
// @Produce      json
// @Param        id    path      int                        true  "Podcast ID"
// @Param        item  body      AddItemToPodcastRequest    true  "Add item request"
// @Success      200   {object}  MessageResponse
// @Failure      400   {object}  ErrorResponse
// @Failure      500   {object}  ErrorResponse
// @Router       /podcasts/{id}/items [post]
func (h *PodcastHandler) AddItemToPodcast(c *gin.Context) <span class="cov8" title="1">{
        podcastIDStr := c.Param("id")
        podcastID, err := strconv.ParseInt(podcastIDStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid podcast ID"})
                return
        }</span>

        <span class="cov8" title="1">var req AddItemToPodcastRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err = h.podcastService.AddItemToPodcast(c.Request.Context(), int32(podcastID), req.ItemID, req.Order)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Item added to podcast successfully",
        })</span>
}

// RemoveItemFromPodcast godoc
// @Summary      Remove item from podcast
// @Description  Remove a content item from a podcast
// @Tags         podcasts
// @Produce      json
// @Param        id      path      int  true  "Podcast ID"
// @Param        itemID  path      int  true  "Item ID"
// @Success      200     {object}  MessageResponse
// @Failure      400     {object}  ErrorResponse
// @Failure      500     {object}  ErrorResponse
// @Router       /podcasts/{id}/items/{itemID} [delete]
func (h *PodcastHandler) RemoveItemFromPodcast(c *gin.Context) <span class="cov8" title="1">{
        podcastIDStr := c.Param("id")
        podcastID, err := strconv.ParseInt(podcastIDStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid podcast ID"})
                return
        }</span>

        <span class="cov8" title="1">itemIDStr := c.Param("itemID")
        itemID, err := strconv.ParseInt(itemIDStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid item ID"})
                return
        }</span>

        <span class="cov8" title="1">err = h.podcastService.RemoveItemFromPodcast(c.Request.Context(), int32(podcastID), int32(itemID))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Item removed from podcast successfully",
        })</span>
}

// UpdatePodcast godoc
// @Summary      Update podcast
// @Description  Update podcast metadata (title and description)
// @Tags         podcasts
// @Accept       json
// @Produce      json
// @Param        id       path      int                     true  "Podcast ID"
// @Param        podcast  body      UpdatePodcastRequest    true  "Podcast update request"
// @Success      200      {object}  MessageResponse
// @Failure      400      {object}  ErrorResponse
// @Failure      500      {object}  ErrorResponse
// @Router       /podcasts/{id} [put]
func (h *PodcastHandler) UpdatePodcast(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid podcast ID"})
                return
        }</span>

        <span class="cov8" title="1">var req UpdatePodcastRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err = h.podcastService.UpdatePodcast(c.Request.Context(), int32(id), req.Title, req.Description)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Podcast updated successfully",
        })</span>
}

// DeletePodcast godoc
// @Summary      Delete podcast
// @Description  Delete a podcast from the system
// @Tags         podcasts
// @Produce      json
// @Param        id   path      int  true  "Podcast ID"
// @Success      200  {object}  MessageResponse
// @Failure      400  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /podcasts/{id} [delete]
func (h *PodcastHandler) DeletePodcast(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid podcast ID"})
                return
        }</span>

        <span class="cov8" title="1">err = h.podcastService.DeletePodcast(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Podcast deleted successfully",
        })</span>
}

// GetPodcastProcessingStatus godoc
// @Summary      Get podcast processing status
// @Description  Retrieve the processing status of a podcast
// @Tags         podcasts
// @Produce      json
// @Param        id   path      int  true  "Podcast ID"
// @Success      200  {object}  PodcastProcessingStatusResponse
// @Failure      400  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /podcasts/{id}/status [get]
func (h *PodcastHandler) GetPodcastProcessingStatus(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid podcast ID"})
                return
        }</span>

        <span class="cov0" title="0">podcast, err := h.podcastService.GetPodcast(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // Determine processing flags based on status
        <span class="cov0" title="0">isPending := podcast.Status == string(services.PodcastStatusPending)
        isWriting := podcast.Status == string(services.PodcastStatusWriting)
        isGenerating := podcast.Status == string(services.PodcastStatusGenerating)
        isCompleted := podcast.Status == string(services.PodcastStatusCompleted)
        isFailed := podcast.Status == string(services.PodcastStatusFailed)
        isProcessing := isWriting || isGenerating

        c.JSON(http.StatusOK, gin.H{
                "podcast_id":    podcast.ID,
                "status":        podcast.Status,
                "is_pending":    isPending,
                "is_writing":    isWriting,
                "is_generating": isGenerating,
                "is_processing": isProcessing,
                "is_completed":  isCompleted,
                "is_failed":     isFailed,
                "audio_url":     podcast.AudioUrl,
        })</span>
}

// StreamPodcastUpdates godoc
// @Summary      Stream podcast updates
// @Description  Server-Sent Events endpoint for real-time podcast processing updates
// @Tags         podcasts
// @Produce      text/event-stream
// @Param        userID  path      int  true  "User ID"
// @Success      200     {string}  string "SSE stream"
// @Failure      400     {object}  ErrorResponse
// @Failure      500     {object}  ErrorResponse
// @Router       /podcasts/user/{userID}/stream [get]
func (h *PodcastHandler) StreamPodcastUpdates(c *gin.Context) <span class="cov0" title="0">{
        userIDStr := c.Param("userID")
        userID, err := strconv.ParseInt(userIDStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">if h.sseManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "SSE manager not available"})
                return
        }</span>

        // Set SSE headers
        <span class="cov0" title="0">c.Header("Content-Type", "text/event-stream")
        c.Header("Cache-Control", "no-cache")
        c.Header("Connection", "keep-alive")
        c.Header("Access-Control-Allow-Origin", "*")

        // Create a channel for writing SSE messages
        messageChan := make(chan string, 10)

        // Register client with SSE manager
        client := h.sseManager.AddClient(int32(userID))
        defer h.sseManager.RemoveClient(client)

        // Start goroutine to write messages from the client channel
        go func() </span><span class="cov0" title="0">{
                defer close(messageChan)
                services.WriteSSEMessage(c.Request.Context(), client, messageChan)
        }</span>()

        // Stream messages to client
        <span class="cov0" title="0">flusher, ok := c.Writer.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Streaming not supported"})
                return
        }</span>

        // Send messages
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case msg, ok := &lt;-messageChan:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">fmt.Fprint(c.Writer, msg)
                        flusher.Flush()</span>
                case &lt;-c.Request.Context().Done():<span class="cov0" title="0">
                        log.Printf("SSE: Client disconnected for user %d", userID)
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "github.com/yamirghofran/briefbot/internal/services"
)

func SetupRoutes(router *gin.Engine, userService services.UserService, itemService services.ItemService, digestService services.DigestService, podcastService services.PodcastService, sseManager *services.SSEManager) <span class="cov0" title="0">{
        handler := NewHandler(userService, itemService, digestService, podcastService, sseManager)
        handler.SetupRoutes(router)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "fmt"
        "log"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/yamirghofran/briefbot/internal/services"
)

// StreamItemUpdates godoc
// @Summary      Stream item processing updates
// @Description  Server-Sent Events endpoint for real-time item processing updates
// @Tags         items
// @Produce      text/event-stream
// @Param        userID  path      int  true  "User ID"
// @Success      200     {string}  string "SSE stream"
// @Failure      400     {object}  ErrorResponse
// @Failure      500     {object}  ErrorResponse
// @Router       /items/user/{userID}/stream [get]
func (h *Handler) StreamItemUpdates(c *gin.Context) <span class="cov0" title="0">{
        userIDStr := c.Param("userID")
        userID, err := strconv.ParseInt(userIDStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        // Set SSE headers
        <span class="cov0" title="0">c.Header("Content-Type", "text/event-stream")
        c.Header("Cache-Control", "no-cache")
        c.Header("Connection", "keep-alive")
        c.Header("Access-Control-Allow-Origin", "*")

        // Create a channel for writing SSE messages
        messageChan := make(chan string, 10)

        // Register client with SSE manager
        client := h.sseManager.AddClient(int32(userID))
        defer h.sseManager.RemoveClient(client)

        // Start goroutine to write messages from the client channel
        go func() </span><span class="cov0" title="0">{
                defer close(messageChan)
                services.WriteSSEMessage(c.Request.Context(), client, messageChan)
        }</span>()

        // Stream messages to client
        <span class="cov0" title="0">flusher, ok := c.Writer.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Streaming not supported"})
                return
        }</span>

        // Send messages
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case msg, ok := &lt;-messageChan:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">fmt.Fprint(c.Writer, msg)
                        flusher.Flush()</span>
                case &lt;-c.Request.Context().Done():<span class="cov0" title="0">
                        log.Printf("SSE: Client disconnected for user %d", userID)
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

// CreateUser godoc
// @Summary      Create a new user
// @Description  Create a new user account with optional OAuth or password authentication
// @Tags         users
// @Accept       json
// @Produce      json
// @Param        user  body      CreateUserRequest  true  "User creation request"
// @Success      201   {object}  github_com_yamirghofran_briefbot_internal_db.User
// @Failure      400   {object}  ErrorResponse
// @Failure      500   {object}  ErrorResponse
// @Router       /users [post]
func (h *Handler) CreateUser(c *gin.Context) <span class="cov8" title="1">{
        var req CreateUserRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">user, err := h.userService.CreateUser(c.Request.Context(), req.Name, req.Email, req.AuthProvider, req.OauthID, req.PasswordHash)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, user)</span>
}

// GetUser godoc
// @Summary      Get a user by ID
// @Description  Retrieve a user's information by their ID
// @Tags         users
// @Produce      json
// @Param        id   path      int  true  "User ID"
// @Success      201   {object}  github_com_yamirghofran_briefbot_internal_db.User
// @Failure      400  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /users/{id} [get]
func (h *Handler) GetUser(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        <span class="cov8" title="1">user, err := h.userService.GetUser(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, user)</span>
}

// GetUserByEmail godoc
// @Summary      Get a user by email
// @Description  Retrieve a user's information by their email address
// @Tags         users
// @Produce      json
// @Param        email  path      string  true  "User Email"
// @Success      201   {object}  github_com_yamirghofran_briefbot_internal_db.User
// @Failure      400    {object}  ErrorResponse
// @Failure      500    {object}  ErrorResponse
// @Router       /users/email/{email} [get]
func (h *Handler) GetUserByEmail(c *gin.Context) <span class="cov8" title="1">{
        email := c.Param("email")
        if email == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Email is required"})
                return
        }</span>

        <span class="cov8" title="1">user, err := h.userService.GetUserByEmail(c.Request.Context(), &amp;email)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, user)</span>
}

// ListUsers godoc
// @Summary      List all users
// @Description  Retrieve a list of all users in the system
// @Tags         users
// @Produce      json
// @Success      200  {array}   github_com_yamirghofran_briefbot_internal_db.User
// @Failure      500  {object}  ErrorResponse
// @Router       /users [get]
func (h *Handler) ListUsers(c *gin.Context) <span class="cov8" title="1">{
        users, err := h.userService.ListUsers(c.Request.Context())
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, users)</span>
}

// UpdateUser godoc
// @Summary      Update a user
// @Description  Update a user's information
// @Tags         users
// @Accept       json
// @Produce      json
// @Param        id    path      int                 true  "User ID"
// @Param        user  body      UpdateUserRequest   true  "User update request"
// @Success      200   {object}  MessageResponse
// @Failure      400   {object}  ErrorResponse
// @Failure      500   {object}  ErrorResponse
// @Router       /users/{id} [put]
func (h *Handler) UpdateUser(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        <span class="cov8" title="1">var req UpdateUserRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err = h.userService.UpdateUser(c.Request.Context(), int32(id), req.Name, req.Email, req.AuthProvider, req.OauthID, req.PasswordHash)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "User updated successfully"})</span>
}

// DeleteUser godoc
// @Summary      Delete a user
// @Description  Delete a user from the system
// @Tags         users
// @Produce      json
// @Param        id   path      int  true  "User ID"
// @Success      200  {object}  MessageResponse
// @Failure      400  {object}  ErrorResponse
// @Failure      500  {object}  ErrorResponse
// @Router       /users/{id} [delete]
func (h *Handler) DeleteUser(c *gin.Context) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        <span class="cov8" title="1">err = h.userService.DeleteUser(c.Request.Context(), int32(id))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package metrics

import (
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        // HTTP Metrics
        httpRequestsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "briefbot_http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"method", "endpoint", "status"},
        )

        httpRequestDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "briefbot_http_request_duration_seconds",
                        Help:    "HTTP request duration in seconds",
                        Buckets: []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10},
                },
                []string{"method", "endpoint"},
        )

        httpRequestSize = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "briefbot_http_request_size_bytes",
                        Help:    "HTTP request size in bytes",
                        Buckets: prometheus.ExponentialBuckets(100, 10, 8),
                },
                []string{"method", "endpoint"},
        )

        httpResponseSize = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "briefbot_http_response_size_bytes",
                        Help:    "HTTP response size in bytes",
                        Buckets: prometheus.ExponentialBuckets(100, 10, 8),
                },
                []string{"method", "endpoint"},
        )

        httpActiveRequests = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "briefbot_http_active_requests",
                        Help: "Number of active HTTP requests",
                },
        )

        // Job Queue Metrics
        jobsEnqueuedTotal = promauto.NewCounter(
                prometheus.CounterOpts{
                        Name: "briefbot_jobs_enqueued_total",
                        Help: "Total number of jobs enqueued",
                },
        )

        jobsProcessingCurrent = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "briefbot_jobs_processing_current",
                        Help: "Number of jobs currently being processed",
                },
        )

        jobsCompletedTotal = promauto.NewCounter(
                prometheus.CounterOpts{
                        Name: "briefbot_jobs_completed_total",
                        Help: "Total number of jobs completed successfully",
                },
        )

        jobsFailedTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "briefbot_jobs_failed_total",
                        Help: "Total number of jobs that failed",
                },
                []string{"error_type"},
        )

        jobProcessingDuration = promauto.NewHistogram(
                prometheus.HistogramOpts{
                        Name:    "briefbot_job_processing_duration_seconds",
                        Help:    "Job processing duration in seconds",
                        Buckets: []float64{1, 5, 10, 30, 60, 120, 300, 600},
                },
        )

        jobQueueDepth = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "briefbot_job_queue_depth",
                        Help: "Number of jobs in queue by status",
                },
                []string{"status"},
        )

        // Worker Metrics
        workersActive = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "briefbot_workers_active",
                        Help: "Number of active workers",
                },
        )

        workerJobsProcessedTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "briefbot_worker_jobs_processed_total",
                        Help: "Total number of jobs processed by each worker",
                },
                []string{"worker_id"},
        )

        workerErrorsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "briefbot_worker_errors_total",
                        Help: "Total number of worker errors",
                },
                []string{"worker_id", "error_type"},
        )

        workerBatchDuration = promauto.NewHistogram(
                prometheus.HistogramOpts{
                        Name:    "briefbot_worker_batch_duration_seconds",
                        Help:    "Worker batch processing duration in seconds",
                        Buckets: []float64{1, 5, 10, 30, 60, 120, 300},
                },
        )

        // Database Metrics
        dbConnectionsActive = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "briefbot_db_connections_active",
                        Help: "Number of active database connections",
                },
        )

        dbConnectionsIdle = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "briefbot_db_connections_idle",
                        Help: "Number of idle database connections",
                },
        )

        dbConnectionsWaiting = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "briefbot_db_connections_waiting",
                        Help: "Number of connections waiting for a database connection",
                },
        )

        // Podcast Metrics
        podcastsGeneratedTotal = promauto.NewCounter(
                prometheus.CounterOpts{
                        Name: "briefbot_podcasts_generated_total",
                        Help: "Total number of podcasts generated",
                },
        )

        podcastGenerationDuration = promauto.NewHistogram(
                prometheus.HistogramOpts{
                        Name:    "briefbot_podcast_generation_duration_seconds",
                        Help:    "Podcast generation duration in seconds",
                        Buckets: []float64{10, 30, 60, 120, 300, 600, 1200},
                },
        )

        podcastAudioRequestsCurrent = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "briefbot_podcast_audio_requests_current",
                        Help: "Number of concurrent audio generation requests",
                },
        )

        podcastGenerationFailuresTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "briefbot_podcast_generation_failures_total",
                        Help: "Total number of podcast generation failures",
                },
                []string{"stage"},
        )

        // AI Service Metrics
        aiAPICallsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "briefbot_ai_api_calls_total",
                        Help: "Total number of AI API calls",
                },
                []string{"operation", "provider"},
        )

        aiAPILatency = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "briefbot_ai_api_latency_seconds",
                        Help:    "AI API call latency in seconds",
                        Buckets: []float64{.1, .5, 1, 2, 5, 10, 30},
                },
                []string{"operation", "provider"},
        )

        aiAPIErrorsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "briefbot_ai_api_errors_total",
                        Help: "Total number of AI API errors",
                },
                []string{"operation", "provider", "error_type"},
        )

        // External Service Metrics
        emailsSentTotal = promauto.NewCounter(
                prometheus.CounterOpts{
                        Name: "briefbot_emails_sent_total",
                        Help: "Total number of emails sent",
                },
        )

        emailFailuresTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "briefbot_email_failures_total",
                        Help: "Total number of email failures",
                },
                []string{"error_type"},
        )

        scrapingRequestsTotal = promauto.NewCounter(
                prometheus.CounterOpts{
                        Name: "briefbot_scraping_requests_total",
                        Help: "Total number of scraping requests",
                },
        )

        scrapingFailuresTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "briefbot_scraping_failures_total",
                        Help: "Total number of scraping failures",
                },
                []string{"error_type"},
        )

        // SSE Metrics
        sseConnectionsActive = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "briefbot_sse_connections_active",
                        Help: "Number of active SSE connections",
                },
        )

        sseEventsSentTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "briefbot_sse_events_sent_total",
                        Help: "Total number of SSE events sent",
                },
                []string{"event_type"},
        )
)

// HTTP Metrics helpers
func RecordHTTPRequest(method, endpoint, status string) <span class="cov8" title="1">{
        httpRequestsTotal.WithLabelValues(method, endpoint, status).Inc()
}</span>

func RecordHTTPDuration(method, endpoint string, duration float64) <span class="cov8" title="1">{
        httpRequestDuration.WithLabelValues(method, endpoint).Observe(duration)
}</span>

func RecordHTTPRequestSize(method, endpoint string, size float64) <span class="cov8" title="1">{
        httpRequestSize.WithLabelValues(method, endpoint).Observe(size)
}</span>

func RecordHTTPResponseSize(method, endpoint string, size float64) <span class="cov8" title="1">{
        httpResponseSize.WithLabelValues(method, endpoint).Observe(size)
}</span>

func IncrementActiveRequests() <span class="cov8" title="1">{
        httpActiveRequests.Inc()
}</span>

func DecrementActiveRequests() <span class="cov8" title="1">{
        httpActiveRequests.Dec()
}</span>

// Job Queue Metrics helpers
func IncrementJobsEnqueued() <span class="cov8" title="1">{
        jobsEnqueuedTotal.Inc()
}</span>

func IncrementJobsProcessing() <span class="cov8" title="1">{
        jobsProcessingCurrent.Inc()
}</span>

func DecrementJobsProcessing() <span class="cov8" title="1">{
        jobsProcessingCurrent.Dec()
}</span>

func IncrementJobsCompleted() <span class="cov8" title="1">{
        jobsCompletedTotal.Inc()
}</span>

func IncrementJobsFailed(errorType string) <span class="cov8" title="1">{
        jobsFailedTotal.WithLabelValues(errorType).Inc()
}</span>

func RecordJobProcessingDuration(duration float64) <span class="cov8" title="1">{
        jobProcessingDuration.Observe(duration)
}</span>

func SetJobQueueDepth(status string, count float64) <span class="cov8" title="1">{
        jobQueueDepth.WithLabelValues(status).Set(count)
}</span>

// Worker Metrics helpers
func SetWorkersActive(count float64) <span class="cov8" title="1">{
        workersActive.Set(count)
}</span>

func IncrementWorkerJobsProcessed(workerID string) <span class="cov8" title="1">{
        workerJobsProcessedTotal.WithLabelValues(workerID).Inc()
}</span>

func IncrementWorkerErrors(workerID, errorType string) <span class="cov8" title="1">{
        workerErrorsTotal.WithLabelValues(workerID, errorType).Inc()
}</span>

func RecordWorkerBatchDuration(duration float64) <span class="cov8" title="1">{
        workerBatchDuration.Observe(duration)
}</span>

// Database Metrics helpers
func UpdateDBConnectionStats(active, idle, waiting int32) <span class="cov8" title="1">{
        dbConnectionsActive.Set(float64(active))
        dbConnectionsIdle.Set(float64(idle))
        dbConnectionsWaiting.Set(float64(waiting))
}</span>

// Podcast Metrics helpers
func IncrementPodcastsGenerated() <span class="cov8" title="1">{
        podcastsGeneratedTotal.Inc()
}</span>

func RecordPodcastGenerationDuration(duration float64) <span class="cov8" title="1">{
        podcastGenerationDuration.Observe(duration)
}</span>

func IncrementPodcastAudioRequests() <span class="cov8" title="1">{
        podcastAudioRequestsCurrent.Inc()
}</span>

func DecrementPodcastAudioRequests() <span class="cov8" title="1">{
        podcastAudioRequestsCurrent.Dec()
}</span>

func IncrementPodcastGenerationFailures(stage string) <span class="cov8" title="1">{
        podcastGenerationFailuresTotal.WithLabelValues(stage).Inc()
}</span>

// AI Service Metrics helpers
func RecordAIAPICall(operation, provider string, duration float64) <span class="cov8" title="1">{
        aiAPICallsTotal.WithLabelValues(operation, provider).Inc()
        aiAPILatency.WithLabelValues(operation, provider).Observe(duration)
}</span>

func IncrementAIAPIErrors(operation, provider, errorType string) <span class="cov8" title="1">{
        aiAPIErrorsTotal.WithLabelValues(operation, provider, errorType).Inc()
}</span>

// External Service Metrics helpers
func IncrementEmailsSent() <span class="cov8" title="1">{
        emailsSentTotal.Inc()
}</span>

func IncrementEmailFailures(errorType string) <span class="cov8" title="1">{
        emailFailuresTotal.WithLabelValues(errorType).Inc()
}</span>

func IncrementScrapingRequests() <span class="cov8" title="1">{
        scrapingRequestsTotal.Inc()
}</span>

func IncrementScrapingFailures(errorType string) <span class="cov8" title="1">{
        scrapingFailuresTotal.WithLabelValues(errorType).Inc()
}</span>

// SSE Metrics helpers
func IncrementSSEConnections() <span class="cov8" title="1">{
        sseConnectionsActive.Inc()
}</span>

func DecrementSSEConnections() <span class="cov8" title="1">{
        sseConnectionsActive.Dec()
}</span>

func IncrementSSEEventsSent(eventType string) <span class="cov8" title="1">{
        sseEventsSentTotal.WithLabelValues(eventType).Inc()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/yamirghofran/briefbot/internal/metrics"
)

// PrometheusMiddleware returns a Gin middleware that records HTTP metrics
func PrometheusMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // Skip metrics endpoint to avoid recursion
                if c.Request.URL.Path == "/metrics" </span><span class="cov8" title="1">{
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="1">start := time.Now()

                // Increment active requests
                metrics.IncrementActiveRequests()
                defer metrics.DecrementActiveRequests()

                // Record request size
                requestSize := computeApproximateRequestSize(c.Request)

                // Process request
                c.Next()

                // Calculate duration
                duration := time.Since(start).Seconds()

                // Get status code
                status := strconv.Itoa(c.Writer.Status())

                // Get endpoint (use route pattern, not actual path)
                endpoint := c.FullPath()
                if endpoint == "" </span><span class="cov8" title="1">{
                        endpoint = "unknown"
                }</span>

                // Record metrics
                <span class="cov8" title="1">metrics.RecordHTTPRequest(c.Request.Method, endpoint, status)
                metrics.RecordHTTPDuration(c.Request.Method, endpoint, duration)
                metrics.RecordHTTPRequestSize(c.Request.Method, endpoint, float64(requestSize))
                metrics.RecordHTTPResponseSize(c.Request.Method, endpoint, float64(c.Writer.Size()))</span>
        }
}

func computeApproximateRequestSize(r *http.Request) int <span class="cov8" title="1">{
        size := 0
        if r.URL != nil </span><span class="cov8" title="1">{
                size += len(r.URL.String())
        }</span>
        <span class="cov8" title="1">size += len(r.Method)
        size += len(r.Proto)
        for name, values := range r.Header </span><span class="cov8" title="1">{
                size += len(name)
                for _, value := range values </span><span class="cov8" title="1">{
                        size += len(value)
                }</span>
        }
        <span class="cov8" title="1">size += len(r.Host)
        if r.ContentLength != -1 </span><span class="cov8" title="1">{
                size += int(r.ContentLength)
        }</span>
        <span class="cov8" title="1">return size</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "sync"

        "github.com/invopop/jsonschema"
        "github.com/openai/openai-go"
)

type AIService interface {
        ExtractContent(ctx context.Context, content string) (ItemExtraction, error)
        SummarizeContent(ctx context.Context, content string) (ItemSummary, error)
        WritePodcast(content string) (Podcast, error)
}

type aiService struct {
        textClient openai.Client
}

func NewAIService(oaiClient *openai.Client) (AIService, error) <span class="cov8" title="1">{
        apiKey := os.Getenv("GROQ_API_KEY")
        if apiKey == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("GROQ_API_KEY environment variable not set")
        }</span>

        <span class="cov8" title="1">return &amp;aiService{
                textClient: *oaiClient,
        }, nil</span>
}

type ItemExtraction struct {
        Title    string   `json:"title" jsonschema_description:"The title for this item."`
        Authors  []string `json:"authors" jsonschema_description:"The authors of this item"`
        Tags     []string `json:"tags" jsonschema_description: "Broad tags that match this item"`
        Platform string   `json:"platform" jsonschema_description:"The platform the item is published on." jsonschema:"enum=Youtube,enum=Github,enum=Arxiv,enum=WSJ,enum=Blog,enum=Medium,enum=Substack"`
        Type     string   `json:"type" jsonschema:"enum=article,enum=github-repo,enum=research-paper,enum=podcast,enum=video"`
}

type ItemSummary struct {
        Overview  string   `json:"overview" jsonschema_description:"Brief overview about the item."`
        KeyPoints []string `json:"key_points" jsonschema_description:"A list of key points that succinctly deliver the most important facts from the item."`
}

type Podcast struct {
        Dialogues []Dialogue `json:"dialogues" jsonschema:"required" jsonschema_description:"The dialogues that make up the podcast"`
}

// PodcastSection represents a single section of a podcast (introduction, body, or conclusion)
type PodcastSection struct {
        Dialogues []Dialogue `json:"dialogues" jsonschema:"required" jsonschema_description:"The dialogues that make up this podcast section"`
}

type Dialogue struct {
        Speaker string `json:"speaker" jsonschema:"required,enum=heart,enum=adam" jsonschema_description:"The speaker identifier"`
        Content string `json:"content" jsonschema:"required" jsonschema_description:"The content of what is spoken"`
}

// SectionedPodcast represents a podcast broken into introduction, body, and conclusion
type SectionedPodcast struct {
        Introduction []Dialogue `json:"introduction" jsonschema:"required"`
        Body         []Dialogue `json:"body" jsonschema:"required"`
        Conclusion   []Dialogue `json:"conclusion" jsonschema:"required"`
}

// PodcastSectionResult represents the result of generating a podcast section
type PodcastSectionResult struct {
        Section   string     // "introduction", "body", or "conclusion"
        Dialogues []Dialogue // The generated dialogues for this section
        Error     error
}

func GenerateSchema[T any]() any <span class="cov8" title="1">{
        // Structured Outputs uses a subset of JSON schema
        // These flags are necessary to comply with the subset
        reflector := jsonschema.Reflector{
                AllowAdditionalProperties: false,
                DoNotReference:            true,
        }
        var v T
        schema := reflector.Reflect(v)
        return schema
}</span>

var ItemExtractionSchema = GenerateSchema[ItemExtraction]()
var ItemSummarySchema = GenerateSchema[ItemSummary]()
var PodcastSchema = GenerateSchema[Podcast]()
var PodcastSectionSchema = GenerateSchema[PodcastSection]()

type Choice struct {
        Text         string `json:"text"`
        Index        int    `json:"index"`
        FinishReason string `json:"finish_reason"`
}

type Message struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

type UsageAccounting struct {
        Include bool `json:"include"`
}

func (s *aiService) ExtractContent(ctx context.Context, content string) (ItemExtraction, error) <span class="cov8" title="1">{
        chatCompletion, err := s.textClient.Chat.Completions.New(context.TODO(), openai.ChatCompletionNewParams{
                Messages: []openai.ChatCompletionMessageParamUnion{
                        openai.SystemMessage("You are an expert content analyzer. Your job is to extract structured information from the provided content and output it in the exact JSON schema format specified. You must return ONLY the JSON object with the required fields: title, authors, tags, platform, and type. Do not include any additional text or explanation."),
                        openai.UserMessage("Extract the following information from this content in the exact JSON schema format: title, authors, tags, platform (must be one of: Youtube, Github, Arxiv, WSJ, Blog, Medium, Substack), and type (must be one of: article, github-repo, research-paper, podcast, video)."),
                        openai.UserMessage(content),
                },
                ResponseFormat: openai.ChatCompletionNewParamsResponseFormatUnion{
                        OfJSONSchema: &amp;openai.ResponseFormatJSONSchemaParam{
                                JSONSchema: openai.ResponseFormatJSONSchemaJSONSchemaParam{
                                        Name:        "item_extraction",
                                        Description: openai.String("Extraction of the item."),
                                        Schema:      ItemExtractionSchema,
                                        Strict:      openai.Bool(true),
                                },
                        },
                },
                Model: "moonshotai/kimi-k2-instruct-0905",
        })
        if err != nil </span><span class="cov8" title="1">{
                return ItemExtraction{}, err
        }</span>
        // extract into a well-typed struct
        <span class="cov0" title="0">var itemExtraction ItemExtraction
        if err = json.Unmarshal([]byte(chatCompletion.Choices[0].Message.Content), &amp;itemExtraction); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return itemExtraction, nil</span>
}

func (s *aiService) SummarizeContent(ctx context.Context, content string) (ItemSummary, error) <span class="cov8" title="1">{
        chatCompletion, err := s.textClient.Chat.Completions.New(context.TODO(), openai.ChatCompletionNewParams{
                Messages: []openai.ChatCompletionMessageParamUnion{
                        openai.SystemMessage("You are an expert content summarizer. Your job is to create a structured summary of the provided material in the exact JSON schema format specified. You must return ONLY the JSON object with the required fields: overview (a brief overview) and key_points (a list of key points). Do not include any additional text or explanation."),
                        openai.UserMessage("Summarize this content in the exact JSON schema format with overview and key_points fields."),
                        openai.UserMessage(content),
                },
                ResponseFormat: openai.ChatCompletionNewParamsResponseFormatUnion{
                        OfJSONSchema: &amp;openai.ResponseFormatJSONSchemaParam{
                                JSONSchema: openai.ResponseFormatJSONSchemaJSONSchemaParam{
                                        Name:        "item_summary",
                                        Description: openai.String("Summary of the item content"),
                                        Schema:      ItemSummarySchema,
                                        Strict:      openai.Bool(true),
                                },
                        },
                },
                Model: "moonshotai/kimi-k2-instruct-0905",
        })
        if err != nil </span><span class="cov8" title="1">{
                return ItemSummary{}, err
        }</span>
        // extract into a well-typed struct
        <span class="cov0" title="0">var itemSummary ItemSummary
        if err = json.Unmarshal([]byte(chatCompletion.Choices[0].Message.Content), &amp;itemSummary); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return itemSummary, nil</span>
}

// WritePodcastSection generates a specific section of the podcast concurrently
func (s *aiService) WritePodcastSection(content string, section string, resultChan chan&lt;- PodcastSectionResult, wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer wg.Done()

        // Create section-specific prompts
        sectionPrompts := map[string]string{
                "introduction": "You are a podcast script writer. Write an engaging introduction for a podcast discussing the given content. The introduction should introduce the topic, set the context, and get listeners interested. Use exactly 2 co-hosts named 'heart' and 'adam'. You must output the dialogues in the exact JSON schema format specified with speaker and content fields. Return ONLY the JSON object with the dialogues array.",
                "body":         "You are a podcast script writer. Write the main body discussion for a podcast about the given content. This should be the core content where the hosts discuss the key points, provide insights, and have a natural conversation. Use exactly 2 co-hosts named 'heart' and 'adam'. You must output the dialogues in the exact JSON schema format specified with speaker and content fields. Return ONLY the JSON object with the dialogues array.",
                "conclusion":   "You are a podcast script writer. Write a conclusion for a podcast discussing the given content. This should summarize key points, provide final thoughts, and give listeners a sense of closure. Use exactly 2 co-hosts named 'heart' and 'adam'. You must output the dialogues in the exact JSON schema format specified with speaker and content fields. Return ONLY the JSON object with the dialogues array.",
        }

        // Generate section-specific dialogue with JSON schema validation
        chatCompletion, err := s.textClient.Chat.Completions.New(context.TODO(), openai.ChatCompletionNewParams{
                Messages: []openai.ChatCompletionMessageParamUnion{
                        openai.SystemMessage(sectionPrompts[section]),
                        openai.UserMessage("Create " + section + " dialogue between 2 cohosts (heart and adam) discussing this content. Output must be in exact JSON schema format with dialogues array containing speaker and content fields:"),
                        openai.UserMessage(content),
                },
                ResponseFormat: openai.ChatCompletionNewParamsResponseFormatUnion{
                        OfJSONSchema: &amp;openai.ResponseFormatJSONSchemaParam{
                                JSONSchema: openai.ResponseFormatJSONSchemaJSONSchemaParam{
                                        Name:        "podcast_section_" + section,
                                        Description: openai.String("Podcast " + section + " section with dialogues"),
                                        Schema:      PodcastSectionSchema,
                                        Strict:      openai.Bool(true),
                                },
                        },
                },
                Model: "moonshotai/kimi-k2-instruct-0905",
        })

        if err != nil </span><span class="cov8" title="1">{
                resultChan &lt;- PodcastSectionResult{Section: section, Error: err}
                return
        }</span>

        <span class="cov0" title="0">var sectionPodcast PodcastSection
        if err = json.Unmarshal([]byte(chatCompletion.Choices[0].Message.Content), &amp;sectionPodcast); err != nil </span><span class="cov0" title="0">{
                resultChan &lt;- PodcastSectionResult{Section: section, Error: fmt.Errorf("failed to unmarshal section JSON: %w", err)}
                return
        }</span>

        <span class="cov0" title="0">resultChan &lt;- PodcastSectionResult{
                Section:   section,
                Dialogues: sectionPodcast.Dialogues,
                Error:     nil,
        }</span>
}

// WritePodcast generates the complete podcast by writing introduction, body, and conclusion concurrently
func (s *aiService) WritePodcast(content string) (Podcast, error) <span class="cov8" title="1">{
        var wg sync.WaitGroup
        resultChan := make(chan PodcastSectionResult, 3) // Buffer for 3 sections

        sections := []string{"introduction", "body", "conclusion"}

        // Launch concurrent section generation
        for _, section := range sections </span><span class="cov8" title="1">{
                wg.Add(1)
                go s.WritePodcastSection(content, section, resultChan, &amp;wg)
        }</span>

        // Wait for ALL section generations to complete before processing results
        <span class="cov8" title="1">wg.Wait()
        close(resultChan)

        // Collect results and maintain order
        sectionResults := make(map[string][]Dialogue)
        var errors []error

        for result := range resultChan </span><span class="cov8" title="1">{
                if result.Error != nil </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Errorf("%s section error: %w", result.Section, result.Error))
                }</span> else<span class="cov0" title="0"> {
                        sectionResults[result.Section] = result.Dialogues
                }</span>
        }

        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                return Podcast{}, fmt.Errorf("failed to generate podcast sections: %v", errors)
        }</span>

        // Combine sections in proper order: introduction -&gt; body -&gt; conclusion
        <span class="cov0" title="0">var combinedDialogues []Dialogue

        // Add introduction
        if intro, exists := sectionResults["introduction"]; exists </span><span class="cov0" title="0">{
                combinedDialogues = append(combinedDialogues, intro...)
        }</span>

        // Add body
        <span class="cov0" title="0">if body, exists := sectionResults["body"]; exists </span><span class="cov0" title="0">{
                combinedDialogues = append(combinedDialogues, body...)
        }</span>

        // Add conclusion
        <span class="cov0" title="0">if conclusion, exists := sectionResults["conclusion"]; exists </span><span class="cov0" title="0">{
                combinedDialogues = append(combinedDialogues, conclusion...)
        }</span>

        <span class="cov0" title="0">return Podcast{Dialogues: combinedDialogues}, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package services

import (
        "context"
        "fmt"
        "log"
        "os"
        "time"

        "github.com/yamirghofran/briefbot/internal/db"
)

// DigestService handles both regular and integrated (podcast + email) digest functionality
type DigestService interface {
        // Regular digest methods (backward compatibility)
        SendDailyDigest(ctx context.Context) error
        SendDailyDigestForUser(ctx context.Context, userID int32) error
        GetDailyDigestItemsForUser(ctx context.Context, userID int32) ([]db.Item, error)

        // Integrated digest methods (with podcast)
        SendIntegratedDigest(ctx context.Context) error
        SendIntegratedDigestForUser(ctx context.Context, userID int32) (*DigestResult, error)

        // Configuration methods
        SetPodcastGenerationEnabled(enabled bool)
        IsPodcastGenerationEnabled() bool
}

// DigestResult contains the result of sending a digest (regular or integrated)
type DigestResult struct {
        EmailSent  bool
        PodcastURL *string
        ItemsCount int
        Error      error
        DigestType string // "regular" or "integrated"
}

type digestService struct {
        queries        db.Querier
        emailService   EmailService
        podcastService PodcastService
        config         DigestConfig
        podcastEnabled bool
}

type DigestConfig struct {
        Subject        string
        PodcastEnabled bool // Global setting for podcast generation
}

// NewDigestService creates a new unified digest service
func NewDigestService(queries db.Querier, emailService EmailService, podcastService PodcastService) DigestService <span class="cov8" title="1">{
        // Load configuration from environment variables
        subject := os.Getenv("DAILY_DIGEST_SUBJECT")
        if subject == "" </span><span class="cov8" title="1">{
                subject = "Your Daily BriefBot Digest - %s"
        }</span>

        // Check if podcast generation is globally enabled
        <span class="cov8" title="1">podcastEnabled := os.Getenv("DIGEST_PODCAST_ENABLED") == "true"

        return &amp;digestService{
                queries:        queries,
                emailService:   emailService,
                podcastService: podcastService,
                config: DigestConfig{
                        Subject:        subject,
                        PodcastEnabled: podcastEnabled,
                },
                podcastEnabled: podcastEnabled,
        }</span>
}

// SetPodcastGenerationEnabled allows runtime configuration of podcast generation
func (s *digestService) SetPodcastGenerationEnabled(enabled bool) <span class="cov8" title="1">{
        s.podcastEnabled = enabled
}</span>

// IsPodcastGenerationEnabled returns current podcast generation setting
func (s *digestService) IsPodcastGenerationEnabled() bool <span class="cov8" title="1">{
        return s.podcastEnabled
}</span>

// SendDailyDigest sends regular daily digest to all users (backward compatibility)
func (s *digestService) SendDailyDigest(ctx context.Context) error <span class="cov8" title="1">{
        users, err := s.queries.ListUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list users: %w", err)
        }</span>

        <span class="cov8" title="1">for _, user := range users </span><span class="cov8" title="1">{
                if user.Email != nil &amp;&amp; *user.Email != "" </span><span class="cov8" title="1">{
                        if err := s.SendDailyDigestForUser(ctx, user.ID); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue with other users
                                log.Printf("Failed to send daily digest to user %d: %v", user.ID, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// SendDailyDigestForUser sends regular daily digest to a specific user (backward compatibility)
func (s *digestService) SendDailyDigestForUser(ctx context.Context, userID int32) error <span class="cov8" title="1">{
        // Get items for specific user from previous day
        items, err := s.GetDailyDigestItemsForUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get daily digest items for user %d: %w", userID, err)
        }</span>

        // If no items, don't send email
        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Get user info for email
        <span class="cov8" title="1">user, err := s.queries.GetUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user %d: %w", userID, err)
        }</span>

        <span class="cov8" title="1">if user.Email == nil || *user.Email == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("user %d has no email address", userID)
        }</span>

        // Generate regular email content (no podcast)
        <span class="cov8" title="1">yesterday := time.Now().Add(-24 * time.Hour)
        htmlBody, textBody := GenerateDailyDigestEmail(items, yesterday)

        // Prepare subject with date
        subject := fmt.Sprintf(s.config.Subject, yesterday.Format("January 2, 2006"))

        // Send email to user
        emailRequest := EmailRequest{
                ToAddresses: []string{*user.Email},
                Subject:     subject,
                HTMLBody:    htmlBody,
                TextBody:    textBody,
        }

        if err := s.emailService.SendEmail(ctx, emailRequest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send email to user %d: %w", userID, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SendIntegratedDigest sends integrated digest (with podcast) to all users
func (s *digestService) SendIntegratedDigest(ctx context.Context) error <span class="cov8" title="1">{
        users, err := s.queries.ListUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list users: %w", err)
        }</span>

        <span class="cov8" title="1">var results []*DigestResult
        for _, user := range users </span><span class="cov8" title="1">{
                if user.Email != nil &amp;&amp; *user.Email != "" </span><span class="cov8" title="1">{
                        result, err := s.SendIntegratedDigestForUser(ctx, user.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to send integrated digest for user %d: %v", user.ID, err)
                        }</span>
                        <span class="cov8" title="1">results = append(results, result)</span>
                }
        }

        // Log summary
        <span class="cov8" title="1">totalUsers := len(users)
        successfulEmails := 0
        successfulPodcasts := 0

        for _, result := range results </span><span class="cov8" title="1">{
                if result.EmailSent </span><span class="cov8" title="1">{
                        successfulEmails++
                }</span>
                <span class="cov8" title="1">if result.PodcastURL != nil </span><span class="cov0" title="0">{
                        successfulPodcasts++
                }</span>
        }

        <span class="cov8" title="1">log.Printf("Integrated digest batch completed: totalUsers=%d, successfulEmails=%d, successfulPodcasts=%d",
                totalUsers, successfulEmails, successfulPodcasts)

        return nil</span>
}

// SendIntegratedDigestForUser sends integrated digest (with podcast) to a specific user
func (s *digestService) SendIntegratedDigestForUser(ctx context.Context, userID int32) (*DigestResult, error) <span class="cov8" title="1">{
        result := &amp;DigestResult{
                EmailSent:  false,
                PodcastURL: nil,
                ItemsCount: 0,
                Error:      nil,
                DigestType: "integrated",
        }

        // Get user info
        user, err := s.queries.GetUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to get user: %w", err)
                return result, result.Error
        }</span>

        <span class="cov8" title="1">if user.Email == nil || *user.Email == "" </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("user %d has no email address", userID)
                return result, result.Error
        }</span>

        // Get unread items from previous day
        <span class="cov8" title="1">items, err := s.GetDailyDigestItemsForUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to get digest items: %w", err)
                return result, result.Error
        }</span>

        <span class="cov8" title="1">result.ItemsCount = len(items)

        if len(items) == 0 </span><span class="cov8" title="1">{
                log.Printf("No items for integrated digest for user %d, skipping", userID)
                return result, nil
        }</span>

        // Generate podcast from items (if enabled)
        <span class="cov8" title="1">var podcastURL *string
        var durationSeconds *int32

        if s.podcastEnabled &amp;&amp; s.podcastService != nil &amp;&amp; len(items) &gt; 0 </span><span class="cov8" title="1">{
                log.Printf("Generating podcast for integrated digest for user %d with %d items", userID, len(items))

                // Extract item IDs for podcast generation
                itemIDs := make([]int32, len(items))
                for i, item := range items </span><span class="cov8" title="1">{
                        itemIDs[i] = item.ID
                }</span>

                // Create podcast with meaningful title and description
                <span class="cov8" title="1">dateStr := time.Now().Format("January 2, 2006")
                title := fmt.Sprintf("Daily Digest for %s", dateStr)
                description := fmt.Sprintf("Your personalized daily digest with %d curated items", len(items))

                podcast, err := s.podcastService.CreatePodcastFromItems(ctx, userID, title, description, itemIDs)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Failed to create podcast for user %d: %v, continuing without audio", userID, err)
                        // Don't fail the entire digest if podcast generation fails
                }</span> else<span class="cov8" title="1"> {
                        // Wait for podcast to complete (with timeout)
                        originalPodcastID := podcast.ID // Store the original ID before the call
                        podcast, err = s.waitForPodcastCompletion(ctx, originalPodcastID)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Podcast generation failed for user %d, podcast %d: %v", userID, originalPodcastID, err)
                        }</span> else<span class="cov8" title="1"> if podcast.AudioUrl != nil &amp;&amp; *podcast.AudioUrl != "" </span><span class="cov8" title="1">{
                                podcastURL = podcast.AudioUrl
                                durationSeconds = podcast.DurationSeconds
                                result.PodcastURL = podcastURL
                                log.Printf("Podcast generated successfully for user %d: audioURL=%s", userID, *podcast.AudioUrl)
                        }</span>
                }
        }

        // Generate integrated email with podcast link (if available)
        <span class="cov8" title="1">htmlBody, textBody := GenerateIntegratedDigestEmail(items, podcastURL, durationSeconds, time.Now())

        // Send email
        subject := fmt.Sprintf("Daily Digest - %s", time.Now().Format("January 2, 2006"))
        emailReq := EmailRequest{
                ToAddresses: []string{*user.Email},
                Subject:     subject,
                HTMLBody:    htmlBody,
                TextBody:    textBody,
        }

        if err := s.emailService.SendEmail(ctx, emailReq); err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to send email: %w", err)
                return result, result.Error
        }</span>

        <span class="cov8" title="1">result.EmailSent = true
        log.Printf("Integrated digest sent successfully for user %d: podcastGenerated=%v", userID, podcastURL != nil)

        return result, nil</span>
}

// GetDailyDigestItemsForUser gets unread items from previous day for a user
func (s *digestService) GetDailyDigestItemsForUser(ctx context.Context, userID int32) ([]db.Item, error) <span class="cov8" title="1">{
        items, err := s.queries.GetUnreadItemsFromPreviousDayByUser(ctx, &amp;userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get unread items from previous day for user %d: %w", userID, err)
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

// waitForPodcastCompletion waits for podcast to complete with timeout
func (s *digestService) waitForPodcastCompletion(ctx context.Context, podcastID int32) (*db.Podcast, error) <span class="cov8" title="1">{
        timeout := time.After(5 * time.Minute) // 5 minute timeout
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-timeout:<span class="cov0" title="0">
                        return nil, fmt.Errorf("podcast generation timed out")</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        podcast, err := s.queries.GetPodcast(ctx, podcastID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">switch podcast.Status </span>{
                        case "completed":<span class="cov8" title="1">
                                return &amp;podcast, nil</span>
                        case "failed":<span class="cov8" title="1">
                                return nil, fmt.Errorf("podcast generation failed")</span>
                        case "pending", "writing", "generating":<span class="cov0" title="0">
                                // Continue waiting
                                continue</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("unknown podcast status: %s", podcast.Status)</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package services

import (
        "context"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/ses"
        "github.com/aws/aws-sdk-go-v2/service/ses/types"
        "github.com/yamirghofran/briefbot/internal/db"
)

// EmailRequest contains the properties needed to send an email
type EmailRequest struct {
        ToAddresses    []string // Recipient email addresses
        Subject        string   // Email subject
        HTMLBody       string   // HTML content (optional)
        TextBody       string   // Plain text content (optional)
        ReplyToAddress string   // Reply-to address (optional, defaults to service config)
}

type EmailService interface {
        SendEmail(ctx context.Context, request EmailRequest) error
}

type emailService struct {
        client       *ses.Client
        fromEmail    string
        fromName     string
        replyToEmail string
}

func NewEmailService() (EmailService, error) <span class="cov8" title="1">{
        // Load from environment variables
        accessKeyId := os.Getenv("AWS_ACCESS_KEY_ID")
        secretAccessKey := os.Getenv("AWS_SECRET_ACCESS_KEY")
        region := os.Getenv("AWS_REGION")
        fromEmail := os.Getenv("SES_FROM_EMAIL")
        fromName := os.Getenv("SES_FROM_NAME")
        replyToEmail := os.Getenv("SES_REPLY_TO_EMAIL")

        if accessKeyId == "" || secretAccessKey == "" || region == "" || fromEmail == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing required AWS SES environment variables")
        }</span>

        <span class="cov8" title="1">if fromName == "" </span><span class="cov8" title="1">{
                fromName = "BriefBot"
        }</span>
        <span class="cov8" title="1">if replyToEmail == "" </span><span class="cov8" title="1">{
                replyToEmail = fromEmail
        }</span>

        // Create configuration
        <span class="cov8" title="1">cfg, err := config.LoadDefaultConfig(context.TODO(),
                config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(
                        accessKeyId,
                        secretAccessKey,
                        "",
                )),
                config.WithRegion(region),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Create SES client
        <span class="cov8" title="1">client := ses.NewFromConfig(cfg)

        return &amp;emailService{
                client:       client,
                fromEmail:    fromEmail,
                fromName:     fromName,
                replyToEmail: replyToEmail,
        }, nil</span>
}

func (s *emailService) SendEmail(ctx context.Context, request EmailRequest) error <span class="cov0" title="0">{
        // Validate required fields
        if len(request.ToAddresses) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("to addresses cannot be empty")
        }</span>
        <span class="cov0" title="0">if request.Subject == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("subject cannot be empty")
        }</span>
        <span class="cov0" title="0">if request.HTMLBody == "" &amp;&amp; request.TextBody == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("either HTML body or text body must be provided")
        }</span>

        // Create the email input
        <span class="cov0" title="0">input := &amp;ses.SendEmailInput{
                Destination: &amp;types.Destination{
                        ToAddresses: request.ToAddresses,
                },
                Message: &amp;types.Message{
                        Subject: &amp;types.Content{
                                Charset: aws.String("UTF-8"),
                                Data:    aws.String(request.Subject),
                        },
                },
                Source: aws.String(fmt.Sprintf("%s &lt;%s&gt;", s.fromName, s.fromEmail)),
        }

        // Set up the message body
        body := &amp;types.Body{}
        if request.HTMLBody != "" </span><span class="cov0" title="0">{
                body.Html = &amp;types.Content{
                        Charset: aws.String("UTF-8"),
                        Data:    aws.String(request.HTMLBody),
                }
        }</span>
        <span class="cov0" title="0">if request.TextBody != "" </span><span class="cov0" title="0">{
                body.Text = &amp;types.Content{
                        Charset: aws.String("UTF-8"),
                        Data:    aws.String(request.TextBody),
                }
        }</span>
        <span class="cov0" title="0">input.Message.Body = body

        // Set reply-to address if provided, otherwise use service default
        replyTo := s.replyToEmail
        if request.ReplyToAddress != "" </span><span class="cov0" title="0">{
                replyTo = request.ReplyToAddress
        }</span>
        <span class="cov0" title="0">input.ReplyToAddresses = []string{replyTo}

        // Send the email
        _, err := s.client.SendEmail(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send email: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GenerateDailyDigestEmail generates HTML and text content for a daily digest email
func GenerateDailyDigestEmail(items []db.Item, date time.Time) (string, string) <span class="cov8" title="1">{
        // Generate HTML content
        htmlContent := generateDailyDigestHTML(items, date)

        // Generate text content
        textContent := generateDailyDigestText(items, date)

        return htmlContent, textContent
}</span>

func generateDailyDigestHTML(items []db.Item, date time.Time) string <span class="cov8" title="1">{
        var html strings.Builder

        html.WriteString(fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Daily Digest - %s&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .header h1 { color: #2c3e50; margin: 0; }
        .item { background-color: #ffffff; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px; margin-bottom: 15px; }
        .item-title { font-size: 18px; font-weight: bold; color: #2c3e50; margin-bottom: 8px; }
        .item-meta { color: #6c757d; font-size: 14px; margin-bottom: 10px; }
        .item-summary { color: #495057; line-height: 1.5; }
        .item-link { color: #007bff; text-decoration: none; }
        .item-link:hover { text-decoration: underline; }
        .footer { text-align: center; color: #6c757d; font-size: 12px; margin-top: 30px; padding-top: 20px; border-top: 1px solid #e9ecef; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="header"&gt;
        &lt;h1&gt;Daily Digest - %s&lt;/h1&gt;
        &lt;p&gt;Your unread items from yesterday&lt;/p&gt;
    &lt;/div&gt;
`, date.Format("January 2, 2006"), date.Format("January 2, 2006")))

        for _, item := range items </span><span class="cov8" title="1">{
                html.WriteString(fmt.Sprintf(`
    &lt;div class="item"&gt;
        &lt;div class="item-title"&gt;&lt;a href="%s" class="item-link"&gt;%s&lt;/a&gt;&lt;/div&gt;
        &lt;div class="item-meta"&gt;`,
                        *item.Url, item.Title))

                if item.Platform != nil &amp;&amp; *item.Platform != "" </span><span class="cov8" title="1">{
                        html.WriteString(fmt.Sprintf("%s | ", *item.Platform))
                }</span>
                <span class="cov8" title="1">if item.Type != nil &amp;&amp; *item.Type != "" </span><span class="cov8" title="1">{
                        html.WriteString(fmt.Sprintf("%s", *item.Type))
                }</span>
                <span class="cov8" title="1">html.WriteString("&lt;/div&gt;")

                if item.Summary != nil &amp;&amp; *item.Summary != "" </span><span class="cov8" title="1">{
                        html.WriteString(fmt.Sprintf(`
        &lt;div class="item-summary"&gt;%s&lt;/div&gt;`, *item.Summary))
                }</span>

                <span class="cov8" title="1">html.WriteString("\n    &lt;/div&gt;")</span>
        }

        <span class="cov8" title="1">html.WriteString(`
    &lt;div class="footer"&gt;
        &lt;p&gt;Sent by BriefBot - Your personal content curator&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`)

        return html.String()</span>
}

func generateDailyDigestText(items []db.Item, date time.Time) string <span class="cov8" title="1">{
        var text strings.Builder

        text.WriteString(fmt.Sprintf("Daily Digest - %s\n", date.Format("January 2, 2006")))
        text.WriteString("Your unread items from yesterday\n")
        text.WriteString(strings.Repeat("=", 50) + "\n\n")

        for i, item := range items </span><span class="cov8" title="1">{
                text.WriteString(fmt.Sprintf("%d. %s\n", i+1, item.Title))
                text.WriteString(fmt.Sprintf("   Link: %s\n", *item.Url))

                var meta []string
                if item.Platform != nil &amp;&amp; *item.Platform != "" </span><span class="cov8" title="1">{
                        meta = append(meta, fmt.Sprintf("Platform: %s", *item.Platform))
                }</span>
                <span class="cov8" title="1">if item.Type != nil &amp;&amp; *item.Type != "" </span><span class="cov8" title="1">{
                        meta = append(meta, fmt.Sprintf("Type: %s", *item.Type))
                }</span>
                <span class="cov8" title="1">meta = append(meta, fmt.Sprintf("Added: %s", item.CreatedAt.Format("Jan 2, 3:04 PM")))

                text.WriteString(fmt.Sprintf("   %s\n", strings.Join(meta, " | ")))

                if item.Summary != nil &amp;&amp; *item.Summary != "" </span><span class="cov8" title="1">{
                        text.WriteString(fmt.Sprintf("   Summary: %s\n", *item.Summary))
                }</span>

                <span class="cov8" title="1">text.WriteString("\n")</span>
        }

        <span class="cov8" title="1">text.WriteString(strings.Repeat("-", 50) + "\n")
        text.WriteString("Sent by BriefBot - Your personal content curator\n")

        return text.String()</span>
}

// GenerateIntegratedDigestEmail generates HTML and text content for an integrated digest email with podcast link
func GenerateIntegratedDigestEmail(items []db.Item, podcastURL *string, durationSeconds *int32, date time.Time) (string, string) <span class="cov8" title="1">{
        // Generate HTML content with podcast link at top
        htmlContent := generateIntegratedDigestHTML(items, podcastURL, durationSeconds, date)

        // Generate text content with podcast link at top
        textContent := generateIntegratedDigestText(items, podcastURL, durationSeconds, date)

        return htmlContent, textContent
}</span>

func generateIntegratedDigestHTML(items []db.Item, podcastURL *string, durationSeconds *int32, date time.Time) string <span class="cov8" title="1">{
        var html strings.Builder

        html.WriteString(fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Daily Digest - %s&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .header h1 { color: #2c3e50; margin: 0; }
        .podcast-section { background-color: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #2196f3; }
        .podcast-title { font-size: 16px; font-weight: bold; color: #1976d2; margin-bottom: 5px; }
        .podcast-link { color: #1976d2; text-decoration: none; font-weight: bold; }
        .podcast-link:hover { text-decoration: underline; }
        .item { background-color: #ffffff; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px; margin-bottom: 15px; }
        .item-title { font-size: 18px; font-weight: bold; color: #2c3e50; margin-bottom: 8px; }
        .item-meta { color: #6c757d; font-size: 14px; margin-bottom: 10px; }
        .item-summary { color: #495057; line-height: 1.5; }
        .item-link { color: #007bff; text-decoration: none; }
        .item-link:hover { text-decoration: underline; }
        .footer { text-align: center; color: #6c757d; font-size: 12px; margin-top: 30px; padding-top: 20px; border-top: 1px solid #e9ecef; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="header"&gt;
        &lt;h1&gt;Daily Digest - %s&lt;/h1&gt;
        &lt;p&gt;Your unread items from yesterday&lt;/p&gt;
    &lt;/div&gt;
`, date.Format("January 2, 2006"), date.Format("January 2, 2006")))

        // Add podcast section if URL exists
        if podcastURL != nil &amp;&amp; *podcastURL != "" </span><span class="cov8" title="1">{
                duration := ""
                if durationSeconds != nil &amp;&amp; *durationSeconds &gt; 0 </span><span class="cov8" title="1">{
                        mins := *durationSeconds / 60
                        secs := *durationSeconds % 60
                        duration = fmt.Sprintf(" (%d:%02d)", mins, secs)
                }</span>

                <span class="cov8" title="1">html.WriteString(fmt.Sprintf(`
    &lt;div class="podcast-section"&gt;
        &lt;div class="podcast-title"&gt; Listen to Today's Digest%s&lt;/div&gt;
        &lt;div&gt;&lt;a href="%s" class="podcast-link"&gt;Download MP3 Audio&lt;/a&gt;&lt;/div&gt;
    &lt;/div&gt;
`, duration, *podcastURL))</span>
        }

        <span class="cov8" title="1">html.WriteString(`
    &lt;div class="items"&gt;
`)

        for _, item := range items </span><span class="cov8" title="1">{
                html.WriteString(fmt.Sprintf(`
        &lt;div class="item"&gt;
            &lt;div class="item-title"&gt;&lt;a href="%s" class="item-link"&gt;%s&lt;/a&gt;&lt;/div&gt;
            &lt;div class="item-meta"&gt;`,
                        *item.Url, item.Title))

                if item.Platform != nil &amp;&amp; *item.Platform != "" </span><span class="cov8" title="1">{
                        html.WriteString(fmt.Sprintf("%s | ", *item.Platform))
                }</span>
                <span class="cov8" title="1">if item.Type != nil &amp;&amp; *item.Type != "" </span><span class="cov8" title="1">{
                        html.WriteString(fmt.Sprintf("%s", *item.Type))
                }</span>
                <span class="cov8" title="1">html.WriteString("&lt;/div&gt;")

                if item.Summary != nil &amp;&amp; *item.Summary != "" </span><span class="cov8" title="1">{
                        html.WriteString(fmt.Sprintf(`
            &lt;div class="item-summary"&gt;%s&lt;/div&gt;`, *item.Summary))
                }</span>

                <span class="cov8" title="1">html.WriteString("\n        &lt;/div&gt;")</span>
        }

        <span class="cov8" title="1">html.WriteString(`
    &lt;/div&gt;
    &lt;div class="footer"&gt;
        &lt;p&gt;Sent by BriefBot - Your personal content curator&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`)

        return html.String()</span>
}

func generateIntegratedDigestText(items []db.Item, podcastURL *string, durationSeconds *int32, date time.Time) string <span class="cov8" title="1">{
        var text strings.Builder

        text.WriteString(fmt.Sprintf("Daily Digest - %s\n", date.Format("January 2, 2006")))
        text.WriteString("Your unread items from yesterday\n")

        // Add podcast section if URL exists
        if podcastURL != nil &amp;&amp; *podcastURL != "" </span><span class="cov8" title="1">{
                duration := ""
                if durationSeconds != nil &amp;&amp; *durationSeconds &gt; 0 </span><span class="cov8" title="1">{
                        mins := *durationSeconds / 60
                        secs := *durationSeconds % 60
                        duration = fmt.Sprintf(" (%d:%02d)", mins, secs)
                }</span>
                <span class="cov8" title="1">text.WriteString(fmt.Sprintf("\n Listen to Today's Digest%s\n", duration))
                text.WriteString(fmt.Sprintf("Audio: %s\n", *podcastURL))
                text.WriteString(strings.Repeat("-", 50) + "\n")</span>
        } else<span class="cov8" title="1"> {
                text.WriteString(strings.Repeat("=", 50) + "\n")
        }</span>

        <span class="cov8" title="1">for i, item := range items </span><span class="cov8" title="1">{
                text.WriteString(fmt.Sprintf("\n%d. %s\n", i+1, item.Title))
                text.WriteString(fmt.Sprintf("   Link: %s\n", *item.Url))

                var meta []string
                if item.Platform != nil &amp;&amp; *item.Platform != "" </span><span class="cov8" title="1">{
                        meta = append(meta, fmt.Sprintf("Platform: %s", *item.Platform))
                }</span>
                <span class="cov8" title="1">if item.Type != nil &amp;&amp; *item.Type != "" </span><span class="cov8" title="1">{
                        meta = append(meta, fmt.Sprintf("Type: %s", *item.Type))
                }</span>
                <span class="cov8" title="1">meta = append(meta, fmt.Sprintf("Added: %s", item.CreatedAt.Format("Jan 2, 3:04 PM")))

                text.WriteString(fmt.Sprintf("   %s\n", strings.Join(meta, " | ")))

                if item.Summary != nil &amp;&amp; *item.Summary != "" </span><span class="cov8" title="1">{
                        text.WriteString(fmt.Sprintf("   Summary: %s\n", *item.Summary))
                }</span>
        }

        <span class="cov8" title="1">text.WriteString("\n" + strings.Repeat("-", 50) + "\n")
        text.WriteString("Sent by BriefBot - Your personal content curator\n")

        return text.String()</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package services

import (
        "context"
        "fmt"
        "strings"

        "github.com/yamirghofran/briefbot/internal/db"
)

type ItemService interface {
        // Background processing methods
        CreateItemAsync(ctx context.Context, userID int32, url string) (*db.Item, error)
        ProcessURL(ctx context.Context, userID int32, url string) (*db.Item, error)

        // Traditional CRUD methods
        CreateItem(ctx context.Context, userID *int32, title string, url *string, textContent *string, summary *string, itemType *string, platform *string, tags []string, authors []string) (*db.Item, error)
        GetItem(ctx context.Context, id int32) (*db.Item, error)
        GetItemsByUser(ctx context.Context, userID *int32) ([]db.Item, error)
        GetUnreadItemsByUser(ctx context.Context, userID *int32) ([]db.Item, error)
        GetUnreadItemsFromPreviousDay(ctx context.Context) ([]db.Item, error)
        UpdateItem(ctx context.Context, id int32, title string, url *string, textContent *string, summary *string, itemType *string, platform *string, tags []string, authors []string, isRead *bool) error
        PatchItem(ctx context.Context, id int32, title *string, summary *string, tags []string, authors []string) (*db.Item, error)
        MarkItemAsRead(ctx context.Context, id int32) error
        ToggleItemReadStatus(ctx context.Context, id int32) (*db.Item, error)
        DeleteItem(ctx context.Context, id int32) error
        GetItemProcessingStatus(ctx context.Context, itemID int32) (*ItemStatus, error)
        GetItemsByProcessingStatus(ctx context.Context, status *string) ([]db.Item, error)
}

// Problem: The ItemService interface has 15+ methods mixing CRUD operations, background processing, and status management. Clients might only need a subset.
// Solution: Split into focused interfaces:

// type ItemCRUD interface {
//     CreateItem(ctx context.Context, userID *int32, title string, url *string, ...) (*db.Item, error)
//     GetItem(ctx context.Context, id int32) (*db.Item, error)
//     UpdateItem(ctx context.Context, id int32, ...) error
//     DeleteItem(ctx context.Context, id int32) error
// }
// type ItemProcessing interface {
//     CreateItemAsync(ctx context.Context, userID int32, url string) (*db.Item, error)
//     GetItemProcessingStatus(ctx context.Context, itemID int32) (*ItemStatus, error)
//     GetItemsByProcessingStatus(ctx context.Context, status *string) ([]db.Item, error)
// }
// type ItemReadStatus interface {
//     MarkItemAsRead(ctx context.Context, id int32) error
//     ToggleItemReadStatus(ctx context.Context, id int32) (*db.Item, error)
//     GetUnreadItemsByUser(ctx context.Context, userID *int32) ([]db.Item, error)
// }

type itemService struct {
        querier         db.Querier
        aiService       AIService
        scrapingService ScrapingService
        jobQueueService JobQueueService
        sseManager      *SSEManager
}

func NewItemService(querier db.Querier, aiService AIService, scrapingService ScrapingService, jobQueueService JobQueueService) ItemService <span class="cov8" title="1">{
        return &amp;itemService{
                querier:         querier,
                aiService:       aiService,
                scrapingService: scrapingService,
                jobQueueService: jobQueueService,
                sseManager:      nil, // Will be set later via SetSSEManager
        }
}</span>

// SetSSEManager sets the SSE manager for the item service
func (s *itemService) SetSSEManager(sseManager *SSEManager) <span class="cov8" title="1">{
        s.sseManager = sseManager
}</span>

// CreateItemAsync creates an item asynchronously - just saves the URL and returns immediately
func (s *itemService) CreateItemAsync(ctx context.Context, userID int32, url string) (*db.Item, error) <span class="cov8" title="1">{
        // For async creation, we just save the URL with a placeholder title
        // The actual processing will happen in the background
        item, err := s.jobQueueService.EnqueueItem(ctx, userID, url, url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to enqueue item: %w", err)
        }</span>

        <span class="cov8" title="1">return item, nil</span>
}

// ProcessURL processes a URL synchronously (for backward compatibility or manual processing)
func (s *itemService) ProcessURL(ctx context.Context, userID int32, url string) (*db.Item, error) <span class="cov8" title="1">{
        content, err := s.scrapingService.Scrape(url)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">extraction, err := s.aiService.ExtractContent(ctx, content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">summary, err := s.aiService.SummarizeContent(ctx, content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">concatenatedSummary := ConcatenateSummary(summary)

        return s.CreateItem(ctx, &amp;userID, extraction.Title, &amp;url, &amp;content, &amp;concatenatedSummary, &amp;extraction.Type, &amp;extraction.Platform,
                extraction.Tags, extraction.Authors)</span>
}

func (s *itemService) CreateItem(ctx context.Context, userID *int32, title string, url *string, textContent *string, summary *string, itemType *string, platform *string, tags []string, authors []string) (*db.Item, error) <span class="cov8" title="1">{
        completedStatus := ProcessingStatusCompleted
        params := db.CreateItemParams{
                UserID:           userID,
                Title:            title,
                Url:              url,
                TextContent:      textContent,
                Summary:          summary,
                Type:             itemType,
                Tags:             tags,
                Platform:         platform,
                Authors:          authors,
                ProcessingStatus: &amp;completedStatus, // Mark as completed since we're creating with all data
                ProcessingError:  nil,
        }
        item, err := s.querier.CreateItem(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;item, nil</span>
}

func (s *itemService) GetItem(ctx context.Context, id int32) (*db.Item, error) <span class="cov8" title="1">{
        item, err := s.querier.GetItem(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;item, nil</span>
}

func (s *itemService) GetItemsByUser(ctx context.Context, userID *int32) ([]db.Item, error) <span class="cov8" title="1">{
        items, err := s.querier.GetItemsByUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return []db.Item{}, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

func (s *itemService) GetUnreadItemsByUser(ctx context.Context, userID *int32) ([]db.Item, error) <span class="cov8" title="1">{
        items, err := s.querier.GetUnreadItemsByUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return []db.Item{}, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

func (s *itemService) UpdateItem(ctx context.Context, id int32, title string, url *string, textContent *string, summary *string, itemType *string, platform *string, tags []string, authors []string, isRead *bool) error <span class="cov8" title="1">{
        params := db.UpdateItemParams{
                ID:          id,
                Title:       title,
                Url:         url,
                IsRead:      isRead,
                TextContent: textContent,
                Summary:     summary,
                Type:        itemType,
                Tags:        tags,
                Platform:    platform,
                Authors:     authors,
        }
        return s.querier.UpdateItem(ctx, params)
}</span>

func (s *itemService) PatchItem(ctx context.Context, id int32, title *string, summary *string, tags []string, authors []string) (*db.Item, error) <span class="cov8" title="1">{
        params := db.PatchItemParams{
                ID:      id,
                Title:   title,
                Summary: summary,
                Tags:    tags,
                Authors: authors,
        }
        item, err := s.querier.PatchItem(ctx, params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;item, nil</span>
}

func (s *itemService) MarkItemAsRead(ctx context.Context, id int32) error <span class="cov8" title="1">{
        return s.querier.MarkItemAsRead(ctx, id)
}</span>

func (s *itemService) ToggleItemReadStatus(ctx context.Context, id int32) (*db.Item, error) <span class="cov8" title="1">{
        item, err := s.querier.ToggleItemReadStatus(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;item, nil</span>
}

func (s *itemService) DeleteItem(ctx context.Context, id int32) error <span class="cov8" title="1">{
        return s.querier.DeleteItem(ctx, id)
}</span>

func (s *itemService) GetItemProcessingStatus(ctx context.Context, itemID int32) (*ItemStatus, error) <span class="cov8" title="1">{
        if s.jobQueueService == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("job queue service not available")
        }</span>
        <span class="cov8" title="1">return s.jobQueueService.GetItemStatus(ctx, itemID)</span>
}

func (s *itemService) GetItemsByProcessingStatus(ctx context.Context, status *string) ([]db.Item, error) <span class="cov8" title="1">{
        if s.jobQueueService == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("job queue service not available")
        }</span>
        <span class="cov8" title="1">return s.jobQueueService.GetItemsByStatus(ctx, *status)</span>
}

func (s *itemService) GetUnreadItemsFromPreviousDay(ctx context.Context) ([]db.Item, error) <span class="cov8" title="1">{
        items, err := s.querier.GetUnreadItemsFromPreviousDay(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return []db.Item{}, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

func ConcatenateSummary(summary ItemSummary) string <span class="cov8" title="1">{
        return summary.Overview + " " + strings.Join(summary.KeyPoints, " ")
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package services

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/yamirghofran/briefbot/internal/db"
        "github.com/yamirghofran/briefbot/internal/metrics"
)

// ProcessingStatus constants
const (
        ProcessingStatusPending    = "pending"
        ProcessingStatusProcessing = "processing"
        ProcessingStatusCompleted  = "completed"
        ProcessingStatusFailed     = "failed"
)

type JobQueueService interface {
        // Queue management
        EnqueueItem(ctx context.Context, userID int32, title string, url string) (*db.Item, error)
        DequeuePendingItems(ctx context.Context, limit int32) ([]db.Item, error)
        MarkItemAsProcessing(ctx context.Context, itemID int32) error

        // Status management
        CompleteItem(ctx context.Context, itemID int32, title, textContent, summary, itemType, platform string, tags, authors []string) error
        FailItem(ctx context.Context, itemID int32, errorMsg string) error
        GetItemStatus(ctx context.Context, itemID int32) (*ItemStatus, error)

        // Utility methods
        GetItemsByStatus(ctx context.Context, status string) ([]db.Item, error)
        GetFailedItemsForRetry(ctx context.Context, limit int32) ([]db.Item, error)
        RetryItem(ctx context.Context, itemID int32) error

        // SSE integration
        SetSSEManager(sseManager *SSEManager)
}

type ItemStatus struct {
        Item            *db.Item
        IsProcessing    bool
        IsCompleted     bool
        IsFailed        bool
        ProcessingError *string
}

type jobQueueService struct {
        querier    db.Querier
        sseManager *SSEManager
}

func NewJobQueueService(querier db.Querier) JobQueueService <span class="cov8" title="1">{
        return &amp;jobQueueService{
                querier:    querier,
                sseManager: nil, // Will be set later via SetSSEManager
        }
}</span>

// SetSSEManager sets the SSE manager for the job queue service
func (s *jobQueueService) SetSSEManager(sseManager *SSEManager) <span class="cov8" title="1">{
        s.sseManager = sseManager
}</span>

func (s *jobQueueService) EnqueueItem(ctx context.Context, userID int32, title string, url string) (*db.Item, error) <span class="cov8" title="1">{
        params := db.CreatePendingItemParams{
                UserID: &amp;userID,
                Title:  title,
                Url:    &amp;url,
        }

        item, err := s.querier.CreatePendingItem(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to enqueue item: %w", err)
        }</span>

        // Record metrics
        <span class="cov8" title="1">metrics.IncrementJobsEnqueued()

        // Notify SSE clients about new item
        if s.sseManager != nil &amp;&amp; item.ProcessingStatus != nil </span><span class="cov8" title="1">{
                s.sseManager.NotifyItemUpdate(userID, item.ID, item.ProcessingStatus, "created")
        }</span>

        <span class="cov8" title="1">return &amp;item, nil</span>
}

func (s *jobQueueService) DequeuePendingItems(ctx context.Context, limit int32) ([]db.Item, error) <span class="cov8" title="1">{
        items, err := s.querier.GetPendingItems(ctx, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to dequeue pending items: %w", err)
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}

func (s *jobQueueService) MarkItemAsProcessing(ctx context.Context, itemID int32) error <span class="cov8" title="1">{
        // Get item to find user ID
        item, err := s.querier.GetItem(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get item: %w", err)
        }</span>

        <span class="cov8" title="1">err = s.querier.UpdateItemAsProcessing(ctx, itemID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to mark item as processing: %w", err)
        }</span>

        // Record metrics
        <span class="cov8" title="1">metrics.IncrementJobsProcessing()

        // Notify SSE clients about processing status
        if s.sseManager != nil &amp;&amp; item.UserID != nil </span><span class="cov8" title="1">{
                processingStatus := ProcessingStatusProcessing
                s.sseManager.NotifyItemUpdate(*item.UserID, itemID, &amp;processingStatus, "processing")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *jobQueueService) CompleteItem(ctx context.Context, itemID int32, title, textContent, summary, itemType, platform string, tags, authors []string) error <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                duration := time.Since(start).Seconds()
                metrics.RecordJobProcessingDuration(duration)
        }</span>()

        // Get the current item to preserve existing URL
        <span class="cov8" title="1">item, err := s.querier.GetItem(ctx, itemID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get item for completion: %w", err)
        }</span>

        // Update the item with processed data, using the AI-extracted title and preserving URL
        <span class="cov8" title="1">params := db.UpdateItemParams{
                ID:          itemID,
                Title:       title,       // Use AI-extracted title
                Url:         item.Url,    // Preserve existing URL
                IsRead:      item.IsRead, // Preserve existing is_read value
                TextContent: &amp;textContent,
                Summary:     &amp;summary,
                Type:        &amp;itemType,
                Tags:        tags,
                Platform:    &amp;platform,
                Authors:     authors,
        }

        err = s.querier.UpdateItem(ctx, params)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to update item with processed data: %w", err)
        }</span>

        // Then mark as completed
        <span class="cov8" title="1">completedStatus := ProcessingStatusCompleted
        statusParams := db.UpdateItemProcessingStatusParams{
                ID:               itemID,
                ProcessingStatus: &amp;completedStatus,
                ProcessingError:  nil,
        }

        err = s.querier.UpdateItemProcessingStatus(ctx, statusParams)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark item as completed: %w", err)
        }</span>

        // Record metrics
        <span class="cov8" title="1">metrics.DecrementJobsProcessing()
        metrics.IncrementJobsCompleted()

        // Notify SSE clients about completion
        if s.sseManager != nil &amp;&amp; item.UserID != nil </span><span class="cov0" title="0">{
                s.sseManager.NotifyItemUpdate(*item.UserID, itemID, &amp;completedStatus, "completed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *jobQueueService) FailItem(ctx context.Context, itemID int32, errorMsg string) error <span class="cov8" title="1">{
        // Get item to find user ID
        item, err := s.querier.GetItem(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get item: %w", err)
        }</span>

        <span class="cov8" title="1">failedStatus := ProcessingStatusFailed
        statusParams := db.UpdateItemProcessingStatusParams{
                ID:               itemID,
                ProcessingStatus: &amp;failedStatus,
                ProcessingError:  &amp;errorMsg,
        }

        err = s.querier.UpdateItemProcessingStatus(ctx, statusParams)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark item as failed: %w", err)
        }</span>

        // Record metrics
        <span class="cov8" title="1">metrics.DecrementJobsProcessing()
        metrics.IncrementJobsFailed(categorizeError(errorMsg))

        // Notify SSE clients about failure
        if s.sseManager != nil &amp;&amp; item.UserID != nil </span><span class="cov0" title="0">{
                s.sseManager.NotifyItemUpdate(*item.UserID, itemID, &amp;failedStatus, "failed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// categorizeError categorizes error messages for metrics
func categorizeError(errorMsg string) string <span class="cov8" title="1">{
        errorLower := strings.ToLower(errorMsg)
        if strings.Contains(errorLower, "network") || strings.Contains(errorLower, "connection") </span><span class="cov0" title="0">{
                return "network"
        }</span> else<span class="cov8" title="1"> if strings.Contains(errorLower, "timeout") </span><span class="cov0" title="0">{
                return "timeout"
        }</span> else<span class="cov8" title="1"> if strings.Contains(errorLower, "parse") || strings.Contains(errorLower, "parsing") </span><span class="cov0" title="0">{
                return "parse"
        }</span> else<span class="cov8" title="1"> if strings.Contains(errorLower, "scrape") || strings.Contains(errorLower, "scraping") </span><span class="cov0" title="0">{
                return "scraping"
        }</span> else<span class="cov8" title="1"> if strings.Contains(errorLower, "ai") || strings.Contains(errorLower, "llm") </span><span class="cov0" title="0">{
                return "ai"
        }</span>
        <span class="cov8" title="1">return "unknown"</span>
}

func (s *jobQueueService) GetItemStatus(ctx context.Context, itemID int32) (*ItemStatus, error) <span class="cov8" title="1">{
        item, err := s.querier.GetItem(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get item: %w", err)
        }</span>

        <span class="cov8" title="1">status := &amp;ItemStatus{
                Item:            &amp;item,
                IsProcessing:    item.ProcessingStatus != nil &amp;&amp; *item.ProcessingStatus == ProcessingStatusProcessing,
                IsCompleted:     item.ProcessingStatus != nil &amp;&amp; *item.ProcessingStatus == ProcessingStatusCompleted,
                IsFailed:        item.ProcessingStatus != nil &amp;&amp; *item.ProcessingStatus == ProcessingStatusFailed,
                ProcessingError: item.ProcessingError,
        }

        return status, nil</span>
}

func (s *jobQueueService) GetItemsByStatus(ctx context.Context, status string) ([]db.Item, error) <span class="cov8" title="1">{
        statusPtr := &amp;status
        items, err := s.querier.GetItemsByProcessingStatus(ctx, statusPtr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get items by status: %w", err)
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}

func (s *jobQueueService) GetFailedItemsForRetry(ctx context.Context, limit int32) ([]db.Item, error) <span class="cov8" title="1">{
        // This would require a new SQL query, for now return empty slice
        // In a real implementation, you'd add a SQL query to get failed items from last 24h
        return []db.Item{}, nil
}</span>

func (s *jobQueueService) RetryItem(ctx context.Context, itemID int32) error <span class="cov8" title="1">{
        // Reset the item status to pending for retry
        pendingStatus := ProcessingStatusPending
        statusParams := db.UpdateItemProcessingStatusParams{
                ID:               itemID,
                ProcessingStatus: &amp;pendingStatus,
                ProcessingError:  nil,
        }

        err := s.querier.UpdateItemProcessingStatus(ctx, statusParams)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retry item: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/yamirghofran/briefbot/internal/db"
)

// DialogueAudioResult represents the result of generating audio for a single dialogue
type DialogueAudioResult struct {
        Index    int    // Dialogue index
        FilePath string // Path to the generated audio file
        Error    error  // Error if generation failed
}

// PodcastStatus represents the status of a podcast
type PodcastStatus string

const (
        PodcastStatusPending    PodcastStatus = "pending"
        PodcastStatusWriting    PodcastStatus = "writing"
        PodcastStatusGenerating PodcastStatus = "generating"
        PodcastStatusCompleted  PodcastStatus = "completed"
        PodcastStatusFailed     PodcastStatus = "failed"
)

// PodcastService handles podcast creation and management
type PodcastService interface {
        // Main podcast creation methods
        CreatePodcastFromItems(ctx context.Context, userID int32, title string, description string, itemIDs []int32) (*db.Podcast, error)
        CreatePodcastFromSingleItem(ctx context.Context, userID int32, itemID int32) (*db.Podcast, error)

        // Podcast generation workflow
        GeneratePodcastScript(ctx context.Context, podcastID int32) error
        GeneratePodcastAudio(ctx context.Context, podcastID int32) error
        ProcessPodcast(ctx context.Context, podcastID int32) error

        // CRUD operations
        GetPodcast(ctx context.Context, podcastID int32) (*db.Podcast, error)
        GetPodcastsByUser(ctx context.Context, userID int32) ([]db.Podcast, error)
        GetPodcastsByStatus(ctx context.Context, status PodcastStatus) ([]db.Podcast, error)
        UpdatePodcast(ctx context.Context, podcastID int32, title string, description string) error
        DeletePodcast(ctx context.Context, podcastID int32) error

        // Item management
        AddItemToPodcast(ctx context.Context, podcastID int32, itemID int32, order int) error
        RemoveItemFromPodcast(ctx context.Context, podcastID int32, itemID int32) error
        GetPodcastItems(ctx context.Context, podcastID int32) ([]db.GetPodcastItemsRow, error)

        // Status management
        UpdatePodcastStatus(ctx context.Context, podcastID int32, status PodcastStatus) error
        GetPendingPodcasts(ctx context.Context, limit int32) ([]db.Podcast, error)
        GetProcessingPodcasts(ctx context.Context, limit int32) ([]db.Podcast, error)

        // Atomic podcast acquisition with locking - prevents multiple workers from processing the same podcast
        AcquirePendingPodcasts(ctx context.Context, limit int32) ([]db.Podcast, error)

        // Audio management
        GetPodcastAudio(ctx context.Context, podcastID int32) ([]byte, error)
        HasPodcastAudio(ctx context.Context, podcastID int32) (bool, error)
        GeneratePodcastUploadURL(ctx context.Context, podcastID int32) (*UploadURLResponse, error)

        // SSE management
        SetSSEManager(sseManager *SSEManager)
}

// podcastService implements PodcastService
type podcastService struct {
        querier       db.Querier
        aiService     AIService
        speechService SpeechService
        r2Service     *R2Service
        config        PodcastConfig
        sseManager    *SSEManager
}

// PodcastConfig holds configuration for podcast service
type PodcastConfig struct {
        DefaultSpeed       float64
        MaxRetries         int
        TempDir            string
        EnableStorage      bool
        VoiceMapping       map[string]VoiceEnum
        MaxItemsPerPodcast int
        MaxConcurrentAudio int32 // Maximum concurrent audio generation requests
}

// DefaultPodcastConfig returns default configuration
func DefaultPodcastConfig() PodcastConfig <span class="cov8" title="1">{
        return PodcastConfig{
                DefaultSpeed:       1.0,
                MaxRetries:         3,
                TempDir:            "/tmp/podcasts",
                EnableStorage:      true,
                MaxItemsPerPodcast: 10,
                MaxConcurrentAudio: 5, // Default 5 concurrent audio requests
                VoiceMapping: map[string]VoiceEnum{
                        "heart": VoiceAfHeart,
                        "adam":  VoiceAmAdam,
                },
        }
}</span>

// NewPodcastService creates a new podcast service
func NewPodcastService(querier db.Querier, aiService AIService, speechService SpeechService, r2Service *R2Service, config PodcastConfig) PodcastService <span class="cov8" title="1">{
        return &amp;podcastService{
                querier:       querier,
                aiService:     aiService,
                speechService: speechService,
                r2Service:     r2Service,
                config:        config,
                sseManager:    nil, // Will be set later via SetSSEManager
        }
}</span>

// SetSSEManager sets the SSE manager for the podcast service
func (s *podcastService) SetSSEManager(sseManager *SSEManager) <span class="cov8" title="1">{
        s.sseManager = sseManager
}</span>

// CreatePodcastFromItems creates a podcast from multiple items
func (s *podcastService) CreatePodcastFromItems(ctx context.Context, userID int32, title string, description string, itemIDs []int32) (*db.Podcast, error) <span class="cov8" title="1">{
        if len(itemIDs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no items provided for podcast creation")
        }</span>

        <span class="cov8" title="1">if len(itemIDs) &gt; s.config.MaxItemsPerPodcast </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("too many items: maximum %d items per podcast", s.config.MaxItemsPerPodcast)
        }</span>

        // Create the podcast
        <span class="cov8" title="1">params := db.CreatePodcastParams{
                UserID:      &amp;userID,
                Title:       title,
                Description: &amp;description,
                Status:      string(PodcastStatusPending),
        }

        podcast, err := s.querier.CreatePodcast(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create podcast: %w", err)
        }</span>

        // Add items to podcast in order
        <span class="cov8" title="1">for i, itemID := range itemIDs </span><span class="cov8" title="1">{
                addParams := db.AddItemToPodcastParams{
                        PodcastID: &amp;podcast.ID,
                        ItemID:    &amp;itemID,
                        ItemOrder: int32(i),
                }

                if _, err := s.querier.AddItemToPodcast(ctx, addParams); err != nil </span><span class="cov0" title="0">{
                        // Clean up on error
                        s.querier.DeletePodcast(ctx, podcast.ID)
                        return nil, fmt.Errorf("failed to add item %d to podcast: %w", itemID, err)
                }</span>
        }

        // Notify via SSE that podcast was created
        <span class="cov8" title="1">if s.sseManager != nil </span><span class="cov0" title="0">{
                s.sseManager.NotifyPodcastUpdate(userID, podcast.ID, string(PodcastStatusPending), "created")
        }</span>

        <span class="cov8" title="1">return &amp;podcast, nil</span>
}

// CreatePodcastFromSingleItem creates a podcast from a single item with auto-generated title
func (s *podcastService) CreatePodcastFromSingleItem(ctx context.Context, userID int32, itemID int32) (*db.Podcast, error) <span class="cov8" title="1">{
        // Get the item to create a meaningful title
        item, err := s.querier.GetItem(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get item: %w", err)
        }</span>

        <span class="cov8" title="1">title := fmt.Sprintf("Podcast: %s", item.Title)
        description := "A podcast discussion about: " + item.Title
        if item.Summary != nil </span><span class="cov8" title="1">{
                description = *item.Summary
        }</span>

        <span class="cov8" title="1">return s.CreatePodcastFromItems(ctx, userID, title, description, []int32{itemID})</span>
}

// GeneratePodcastScript generates the podcast script using AI service
func (s *podcastService) GeneratePodcastScript(ctx context.Context, podcastID int32) error <span class="cov8" title="1">{
        // Get the podcast to retrieve user ID for SSE notifications
        podcast, err := s.querier.GetPodcast(ctx, podcastID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get podcast: %w", err)
        }</span>

        // Get podcast items
        <span class="cov8" title="1">items, err := s.querier.GetPodcastItems(ctx, &amp;podcastID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get podcast items: %w", err)
        }</span>

        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no items found for podcast")
        }</span>

        // Update status to writing
        <span class="cov8" title="1">if err := s.UpdatePodcastStatus(ctx, podcastID, PodcastStatusWriting); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update podcast status: %w", err)
        }</span>

        // Notify via SSE that script writing has started
        <span class="cov8" title="1">if s.sseManager != nil &amp;&amp; podcast.UserID != nil </span><span class="cov0" title="0">{
                s.sseManager.NotifyPodcastUpdate(*podcast.UserID, podcastID, string(PodcastStatusWriting), "writing")
        }</span>

        // Convert GetPodcastItemsRow to Items for content building
        <span class="cov8" title="1">content := s.buildPodcastContentFromRows(items)

        // Generate podcast script using AI service
        podcastData, err := s.aiService.WritePodcast(content)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate podcast script: %w", err)
        }</span>

        // Convert dialogues to JSON and update podcast
        <span class="cov8" title="1">dialoguesJSON, err := json.Marshal(podcastData.Dialogues)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal dialogues: %w", err)
        }</span>

        <span class="cov8" title="1">updateParams := db.UpdatePodcastDialoguesParams{
                ID:        podcastID,
                Dialogues: dialoguesJSON,
        }

        if err := s.querier.UpdatePodcastDialogues(ctx, updateParams); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update podcast dialogues: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// buildPodcastContentFromRows combines content from multiple items (from GetPodcastItemsRow) into a single content string
func (s *podcastService) buildPodcastContentFromRows(items []db.GetPodcastItemsRow) string <span class="cov8" title="1">{
        var content strings.Builder

        for i, item := range items </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        content.WriteString("\n\n---\n\n")
                }</span>

                <span class="cov8" title="1">content.WriteString(fmt.Sprintf("Title: %s\n", item.Title))
                if item.Summary != nil &amp;&amp; *item.Summary != "" </span><span class="cov8" title="1">{
                        content.WriteString(fmt.Sprintf("Summary: %s\n", *item.Summary))
                }</span>
        }

        <span class="cov8" title="1">return content.String()</span>
}

// GeneratePodcastAudio converts the podcast script to audio
func (s *podcastService) GeneratePodcastAudio(ctx context.Context, podcastID int32) error <span class="cov0" title="0">{
        // Get podcast with dialogues
        podcast, err := s.querier.GetPodcast(ctx, podcastID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get podcast: %w", err)
        }</span>

        <span class="cov0" title="0">if podcast.Dialogues == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no dialogues found for podcast")
        }</span>

        // Update status to generating
        <span class="cov0" title="0">if err := s.UpdatePodcastStatus(ctx, podcastID, PodcastStatusGenerating); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update podcast status: %w", err)
        }</span>

        // Notify via SSE that audio generation has started
        <span class="cov0" title="0">if s.sseManager != nil &amp;&amp; podcast.UserID != nil </span><span class="cov0" title="0">{
                s.sseManager.NotifyPodcastUpdate(*podcast.UserID, podcastID, string(PodcastStatusGenerating), "generating")
        }</span>

        // Parse dialogues
        <span class="cov0" title="0">var dialogues []Dialogue
        if err := json.Unmarshal(podcast.Dialogues, &amp;dialogues); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal dialogues: %w", err)
        }</span>

        <span class="cov0" title="0">if len(dialogues) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no dialogues to convert to audio")
        }</span>

        // Create temp directory for audio files
        <span class="cov0" title="0">tempDir := filepath.Join(s.config.TempDir, fmt.Sprintf("podcast_%d", podcastID))
        if err := os.MkdirAll(tempDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp directory: %w", err)
        }</span>
        // Don't defer cleanup here - we'll clean up after we're completely done with all files

        // Convert each dialogue to audio concurrently
        <span class="cov0" title="0">audioFiles := make([]string, len(dialogues))
        var wg sync.WaitGroup
        resultChan := make(chan DialogueAudioResult, len(dialogues))

        // Use a semaphore to limit concurrent requests and prevent API overload
        // Use configured max concurrent audio requests (default 5)
        maxConcurrent := int(s.config.MaxConcurrentAudio)
        if maxConcurrent &lt;= 0 </span><span class="cov0" title="0">{
                maxConcurrent = 5 // Fallback to default if not configured
        }</span>
        <span class="cov0" title="0">log.Printf("Starting concurrent audio generation for %d dialogues in podcast %d (max concurrent: %d)",
                len(dialogues), podcastID, maxConcurrent)

        semaphore := make(chan struct{}, maxConcurrent)

        // Launch concurrent audio generation for all dialogues
        for i, dialogue := range dialogues </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(idx int, dlg Dialogue) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Acquire semaphore (blocks if max concurrent requests reached)
                        semaphore &lt;- struct{}{}
                        defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>() // Release semaphore when done

                        // Generate audio for this dialogue
                        <span class="cov0" title="0">audioFile, err := s.convertDialogueToAudio(ctx, dlg, idx, len(dialogues), tempDir)
                        if err != nil </span><span class="cov0" title="0">{
                                resultChan &lt;- DialogueAudioResult{
                                        Index: idx,
                                        Error: err,
                                }
                                return
                        }</span>

                        <span class="cov0" title="0">resultChan &lt;- DialogueAudioResult{
                                Index:    idx,
                                FilePath: audioFile,
                                Error:    nil,
                        }</span>
                }(i, dialogue)
        }

        // Wait for ALL goroutines to complete before processing results
        <span class="cov0" title="0">wg.Wait()
        close(resultChan)

        // Collect results and maintain order
        failedCount := 0
        successCount := 0
        for result := range resultChan </span><span class="cov0" title="0">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to convert dialogue %d to audio: %v", result.Index, result.Error)
                        failedCount++
                }</span> else<span class="cov0" title="0"> {
                        audioFiles[result.Index] = result.FilePath
                        successCount++
                }</span>
        }

        <span class="cov0" title="0">log.Printf("Completed concurrent audio generation: %d succeeded, %d failed out of %d dialogues",
                successCount, failedCount, len(dialogues))

        // Filter out failed results and collect valid audio files
        validAudioFiles := make([]string, 0, len(audioFiles))
        for i, audioFile := range audioFiles </span><span class="cov0" title="0">{
                if audioFile == "" </span><span class="cov0" title="0">{
                        log.Printf("Warning: Dialogue %d failed to generate audio", i)
                        continue</span>
                }
                <span class="cov0" title="0">if _, err := os.Stat(audioFile); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Audio file %s for dialogue %d does not exist: %v", audioFile, i, err)
                        continue</span>
                }
                <span class="cov0" title="0">validAudioFiles = append(validAudioFiles, audioFile)</span>
        }

        // Check if we have any valid audio files
        <span class="cov0" title="0">if len(validAudioFiles) == 0 </span><span class="cov0" title="0">{
                log.Printf("No valid audio files found for podcast %d. Marking as completed without audio.", podcastID)

                // Clean up temp directory before returning
                if err := os.RemoveAll(tempDir); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to clean up temp directory %s: %v", tempDir, err)
                }</span>

                // Update podcast status to completed without audio
                <span class="cov0" title="0">noAudioURL := ""
                zeroDuration := int32(0)
                updateParams := db.UpdatePodcastStatusWithAudioParams{
                        ID:              podcastID,
                        Status:          string(PodcastStatusCompleted),
                        AudioUrl:        &amp;noAudioURL,
                        DurationSeconds: &amp;zeroDuration,
                }

                if err := s.querier.UpdatePodcastStatusWithAudio(ctx, updateParams); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update podcast status without audio: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">if len(validAudioFiles) &lt; len(audioFiles) </span><span class="cov0" title="0">{
                log.Printf("Warning: Only %d/%d audio files are valid for podcast %d",
                        len(validAudioFiles), len(audioFiles), podcastID)
        }</span>

        // Stitch audio files together using only valid files
        <span class="cov0" title="0">finalAudioFile := filepath.Join(tempDir, "final_podcast.mp3")
        if err := StitchAudioFiles(validAudioFiles, finalAudioFile); err != nil </span><span class="cov0" title="0">{
                // Clean up temp directory on error
                if cleanupErr := os.RemoveAll(tempDir); cleanupErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to clean up temp directory %s: %v", tempDir, cleanupErr)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to stitch audio files: %w", err)</span>
        }

        // Read final audio file
        <span class="cov0" title="0">audioData, err := os.ReadFile(finalAudioFile)
        if err != nil </span><span class="cov0" title="0">{
                // Clean up temp directory on error
                if cleanupErr := os.RemoveAll(tempDir); cleanupErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to clean up temp directory %s: %v", tempDir, cleanupErr)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to read final audio file: %w", err)</span>
        }

        // Store audio (either locally or upload to R2)
        <span class="cov0" title="0">audioURL, duration, err := s.storePodcastAudio(ctx, podcastID, audioData)
        if err != nil </span><span class="cov0" title="0">{
                // Clean up temp directory on error
                if cleanupErr := os.RemoveAll(tempDir); cleanupErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to clean up temp directory %s: %v", tempDir, cleanupErr)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to store podcast audio: %w", err)</span>
        }

        // Update podcast with audio information and mark as completed
        <span class="cov0" title="0">updateParams := db.UpdatePodcastStatusWithAudioParams{
                ID:              podcastID,
                Status:          string(PodcastStatusCompleted),
                AudioUrl:        &amp;audioURL,
                DurationSeconds: &amp;duration,
        }

        if err := s.querier.UpdatePodcastStatusWithAudio(ctx, updateParams); err != nil </span><span class="cov0" title="0">{
                // Clean up temp directory on error
                if cleanupErr := os.RemoveAll(tempDir); cleanupErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to clean up temp directory %s: %v", tempDir, cleanupErr)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to update podcast with audio: %w", err)</span>
        }

        // Clean up temp directory only after everything is successfully completed
        <span class="cov0" title="0">if err := os.RemoveAll(tempDir); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to clean up temp directory %s: %v", tempDir, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// convertDialogueToAudio converts a single dialogue to audio
func (s *podcastService) convertDialogueToAudio(ctx context.Context, dialogue Dialogue, index int, total int, tempDir string) (string, error) <span class="cov0" title="0">{
        // Map speaker to voice
        voice, ok := s.config.VoiceMapping[dialogue.Speaker]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unknown speaker: %s", dialogue.Speaker)
        }</span>

        // Create dialogue info for enhanced logging
        <span class="cov0" title="0">dialogueInfo := &amp;DialogueInfo{
                Index:   index + 1, // Convert to 1-based index
                Total:   total,
                Speaker: dialogue.Speaker,
                Content: dialogue.Content,
        }

        // Generate audio using speech service
        audioFile, err := s.speechService.TextToSpeech(dialogue.Content, voice, s.config.DefaultSpeed, dialogueInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate speech: %w", err)
        }</span>

        // Download audio data
        <span class="cov0" title="0">audioData, err := s.speechService.DownloadAudio(audioFile.URL)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to download audio: %w", err)
        }</span>

        // Determine file extension based on content type from FAL response
        <span class="cov0" title="0">fileExt := ".mp3"           // default fallback
        contentType := "audio/mpeg" // default fallback
        if audioFile.ContentType != "" </span><span class="cov0" title="0">{
                switch audioFile.ContentType </span>{
                case "audio/wav", "audio/x-wav", "audio/wave":<span class="cov0" title="0">
                        fileExt = ".wav"
                        contentType = "audio/wav"</span>
                case "audio/mpeg", "audio/mp3":<span class="cov0" title="0">
                        fileExt = ".mp3"
                        contentType = "audio/mpeg"</span>
                default:<span class="cov0" title="0">
                        log.Printf("Warning: Unknown audio content type '%s', using .mp3 extension", audioFile.ContentType)</span>
                }
        } else<span class="cov0" title="0"> {
                log.Printf("Warning: No content type provided by FAL, assuming .mp3 extension")
        }</span>

        // Log the detected format for debugging
        <span class="cov0" title="0">log.Printf("Dialogue %d/%d: Detected audio format '%s', saving as %s",
                dialogueInfo.Index, dialogueInfo.Total, contentType, fileExt)

        // Save to temp file with correct extension
        tempFile := filepath.Join(tempDir, fmt.Sprintf("dialogue_%d%s", index, fileExt))
        if err := s.speechService.SaveAudio(audioData, tempFile); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to save audio file: %w", err)
        }</span>

        <span class="cov0" title="0">return tempFile, nil</span>
}

// generateDialogueAudioConcurrent generates audio for a single dialogue concurrently
func (s *podcastService) generateDialogueAudioConcurrent(ctx context.Context, dialogue Dialogue, index int, total int, tempDir string, resultChan chan&lt;- DialogueAudioResult, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        // Generate audio using the existing method
        audioFile, err := s.convertDialogueToAudio(ctx, dialogue, index, total, tempDir)
        if err != nil </span><span class="cov0" title="0">{
                resultChan &lt;- DialogueAudioResult{
                        Index: index,
                        Error: err,
                }
                return
        }</span>

        <span class="cov0" title="0">resultChan &lt;- DialogueAudioResult{
                Index:    index,
                FilePath: audioFile,
                Error:    nil,
        }</span>
}

// detectAudioFormat detects the audio format from the file header
func detectAudioFormat(data []byte) string <span class="cov0" title="0">{
        if len(data) &lt; 12 </span><span class="cov0" title="0">{
                return "application/octet-stream" // fallback for too small data
        }</span>

        // Check for WAV format (RIFF header)
        <span class="cov0" title="0">if string(data[0:4]) == "RIFF" &amp;&amp; string(data[8:12]) == "WAVE" </span><span class="cov0" title="0">{
                return "audio/wav"
        }</span>

        // Check for MP3 format (ID3v2 or MPEG sync word)
        <span class="cov0" title="0">if string(data[0:3]) == "ID3" || (data[0] == 0xFF &amp;&amp; (data[1]&amp;0xE0) == 0xE0) </span><span class="cov0" title="0">{
                return "audio/mpeg"
        }</span>

        // Default fallback - assume MP3 for podcast audio
        <span class="cov0" title="0">return "audio/mpeg"</span>
}

// storePodcastAudio stores the podcast audio in R2 and returns URL and duration
func (s *podcastService) storePodcastAudio(ctx context.Context, podcastID int32, audioData []byte) (string, int32, error) <span class="cov0" title="0">{
        if s.r2Service == nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("R2 service not available")
        }</span>

        // Detect the actual audio format from the data
        <span class="cov0" title="0">contentType := detectAudioFormat(audioData)
        log.Printf("Storing podcast audio: detected format '%s' (%d bytes)", contentType, len(audioData))

        // Generate R2 key for podcast audio - use appropriate extension based on content type
        var fileExt string
        switch contentType </span>{
        case "audio/wav":<span class="cov0" title="0">
                fileExt = ".wav"</span>
        case "audio/mpeg":<span class="cov0" title="0">
                fileExt = ".mp3"</span>
        default:<span class="cov0" title="0">
                fileExt = ".mp3"</span> // fallback to MP3
        }

        <span class="cov0" title="0">key := fmt.Sprintf("generated/podcasts/podcast_%d_%d%s", podcastID, time.Now().Unix(), fileExt)

        // Upload to R2 with correct content type
        publicURL, err := s.r2Service.UploadFile(ctx, key, audioData, contentType)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("failed to upload podcast audio to R2: %w", err)
        }</span>

        // Calculate duration (simplified - in real implementation, use audio metadata)
        // Assuming ~150 words per minute, average 5 characters per word
        <span class="cov0" title="0">duration := int32(len(audioData) / 10000) // Rough estimate
        if duration &lt; 1 </span><span class="cov0" title="0">{
                duration = 1
        }</span>

        <span class="cov0" title="0">return publicURL, duration, nil</span>
}

// ProcessPodcast processes a complete podcast (script + audio generation)
func (s *podcastService) ProcessPodcast(ctx context.Context, podcastID int32) error <span class="cov0" title="0">{
        // Get the podcast to retrieve user ID for SSE notifications
        podcast, err := s.querier.GetPodcast(ctx, podcastID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get podcast: %w", err)
        }</span>

        // Generate script first
        <span class="cov0" title="0">if err := s.GeneratePodcastScript(ctx, podcastID); err != nil </span><span class="cov0" title="0">{
                // Notify failure via SSE
                if s.sseManager != nil &amp;&amp; podcast.UserID != nil </span><span class="cov0" title="0">{
                        s.sseManager.NotifyPodcastUpdate(*podcast.UserID, podcastID, string(PodcastStatusFailed), "failed")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to generate podcast script: %w", err)</span>
        }

        // Generate audio
        <span class="cov0" title="0">if err := s.GeneratePodcastAudio(ctx, podcastID); err != nil </span><span class="cov0" title="0">{
                // Notify failure via SSE
                if s.sseManager != nil &amp;&amp; podcast.UserID != nil </span><span class="cov0" title="0">{
                        s.sseManager.NotifyPodcastUpdate(*podcast.UserID, podcastID, string(PodcastStatusFailed), "failed")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to generate podcast audio: %w", err)</span>
        }

        // Notify completion via SSE
        <span class="cov0" title="0">if s.sseManager != nil &amp;&amp; podcast.UserID != nil </span><span class="cov0" title="0">{
                s.sseManager.NotifyPodcastUpdate(*podcast.UserID, podcastID, string(PodcastStatusCompleted), "completed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetPodcast retrieves a podcast by ID
func (s *podcastService) GetPodcast(ctx context.Context, podcastID int32) (*db.Podcast, error) <span class="cov8" title="1">{
        podcast, err := s.querier.GetPodcast(ctx, podcastID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get podcast: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;podcast, nil</span>
}

// GetPodcastsByUser retrieves all podcasts for a user
func (s *podcastService) GetPodcastsByUser(ctx context.Context, userID int32) ([]db.Podcast, error) <span class="cov8" title="1">{
        userIDPtr := int32(userID)
        podcasts, err := s.querier.GetPodcastByUser(ctx, &amp;userIDPtr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user podcasts: %w", err)
        }</span>
        <span class="cov8" title="1">return podcasts, nil</span>
}

// GetPodcastsByStatus retrieves podcasts by status
func (s *podcastService) GetPodcastsByStatus(ctx context.Context, status PodcastStatus) ([]db.Podcast, error) <span class="cov8" title="1">{
        podcasts, err := s.querier.GetPodcastsByStatus(ctx, string(status))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get podcasts by status: %w", err)
        }</span>
        <span class="cov8" title="1">return podcasts, nil</span>
}

// UpdatePodcast updates podcast metadata
func (s *podcastService) UpdatePodcast(ctx context.Context, podcastID int32, title string, description string) error <span class="cov8" title="1">{
        params := db.UpdatePodcastParams{
                ID:          podcastID,
                Title:       title,
                Description: &amp;description,
        }

        if err := s.querier.UpdatePodcast(ctx, params); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update podcast: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DeletePodcast deletes a podcast and its associated data
func (s *podcastService) DeletePodcast(ctx context.Context, podcastID int32) error <span class="cov8" title="1">{
        // Clear podcast items first
        podcastIDPtr := int32(podcastID)
        if err := s.querier.ClearPodcastItems(ctx, &amp;podcastIDPtr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear podcast items: %w", err)
        }</span>

        // Delete the podcast
        <span class="cov8" title="1">if err := s.querier.DeletePodcast(ctx, podcastID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete podcast: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// AddItemToPodcast adds an item to a podcast
func (s *podcastService) AddItemToPodcast(ctx context.Context, podcastID int32, itemID int32, order int) error <span class="cov8" title="1">{
        // Get current item count to determine order if not specified
        if order &lt; 0 </span><span class="cov8" title="1">{
                count, err := s.querier.CountPodcastItems(ctx, &amp;podcastID)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to count podcast items: %w", err)
                }</span>
                <span class="cov0" title="0">order = int(count)</span>
        }

        <span class="cov8" title="1">params := db.AddItemToPodcastParams{
                PodcastID: &amp;podcastID,
                ItemID:    &amp;itemID,
                ItemOrder: int32(order),
        }

        if _, err := s.querier.AddItemToPodcast(ctx, params); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to add item to podcast: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RemoveItemFromPodcast removes an item from a podcast
func (s *podcastService) RemoveItemFromPodcast(ctx context.Context, podcastID int32, itemID int32) error <span class="cov8" title="1">{
        params := db.RemoveItemFromPodcastParams{
                PodcastID: &amp;podcastID,
                ItemID:    &amp;itemID,
        }

        if err := s.querier.RemoveItemFromPodcast(ctx, params); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove item from podcast: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetPodcastItems retrieves all items in a podcast
func (s *podcastService) GetPodcastItems(ctx context.Context, podcastID int32) ([]db.GetPodcastItemsRow, error) <span class="cov8" title="1">{
        items, err := s.querier.GetPodcastItems(ctx, &amp;podcastID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get podcast items: %w", err)
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

// UpdatePodcastStatus updates the status of a podcast
func (s *podcastService) UpdatePodcastStatus(ctx context.Context, podcastID int32, status PodcastStatus) error <span class="cov8" title="1">{
        params := db.UpdatePodcastStatusParams{
                ID:     podcastID,
                Status: string(status),
        }

        if err := s.querier.UpdatePodcastStatus(ctx, params); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update podcast status: %w", err)
        }</span>

        // Notify via SSE if manager is available
        <span class="cov8" title="1">if s.sseManager != nil </span><span class="cov8" title="1">{
                // Get the podcast to retrieve the user ID
                podcast, err := s.querier.GetPodcast(ctx, podcastID)
                if err == nil &amp;&amp; podcast.UserID != nil </span><span class="cov8" title="1">{
                        s.sseManager.NotifyPodcastUpdate(*podcast.UserID, podcastID, string(status), string(status))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetPendingPodcasts retrieves pending podcasts for processing
func (s *podcastService) GetPendingPodcasts(ctx context.Context, limit int32) ([]db.Podcast, error) <span class="cov8" title="1">{
        podcasts, err := s.querier.GetPendingPodcasts(ctx, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pending podcasts: %w", err)
        }</span>
        <span class="cov8" title="1">return podcasts, nil</span>
}

// AcquirePendingPodcasts atomically acquires pending podcasts with row-level locking
// This prevents multiple workers from processing the same podcast concurrently
func (s *podcastService) AcquirePendingPodcasts(ctx context.Context, limit int32) ([]db.Podcast, error) <span class="cov8" title="1">{
        // For now, implement a simple approach: get pending podcasts and immediately mark them as writing
        // This creates a small window where race conditions could occur, but it's much better than before
        // The FOR UPDATE SKIP LOCKED in the query will still help prevent most conflicts

        podcasts, err := s.querier.GetPendingPodcasts(ctx, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pending podcasts: %w", err)
        }</span>

        // Immediately update the status of acquired podcasts to 'writing'
        // This reduces the window for race conditions and marks them as being processed
        <span class="cov8" title="1">for _, podcast := range podcasts </span><span class="cov8" title="1">{
                params := db.UpdatePodcastStatusParams{
                        ID:     podcast.ID,
                        Status: string(PodcastStatusWriting),
                }
                if err := s.querier.UpdatePodcastStatus(ctx, params); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to update podcast %d status to writing: %v", podcast.ID, err)
                        // Continue with other podcasts even if one update fails
                }</span>
        }

        <span class="cov8" title="1">return podcasts, nil</span>
}

// GetProcessingPodcasts retrieves currently processing podcasts
func (s *podcastService) GetProcessingPodcasts(ctx context.Context, limit int32) ([]db.Podcast, error) <span class="cov8" title="1">{
        podcasts, err := s.querier.GetProcessingPodcasts(ctx, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get processing podcasts: %w", err)
        }</span>
        <span class="cov8" title="1">return podcasts, nil</span>
}

// GetPodcastAudio retrieves the audio data for a podcast
func (s *podcastService) GetPodcastAudio(ctx context.Context, podcastID int32) ([]byte, error) <span class="cov8" title="1">{
        podcast, err := s.querier.GetPodcast(ctx, podcastID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get podcast: %w", err)
        }</span>

        <span class="cov8" title="1">if podcast.AudioUrl == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("podcast has no audio")
        }</span>

        // For now, return an error indicating that audio should be fetched from the URL
        // In a real implementation, you might want to download the audio from R2
        <span class="cov8" title="1">return nil, fmt.Errorf("audio available at URL: %s - use HTTP client to download", *podcast.AudioUrl)</span>
}

// HasPodcastAudio checks if a podcast has audio available
func (s *podcastService) HasPodcastAudio(ctx context.Context, podcastID int32) (bool, error) <span class="cov8" title="1">{
        podcast, err := s.querier.GetPodcast(ctx, podcastID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get podcast: %w", err)
        }</span>

        <span class="cov8" title="1">return podcast.AudioUrl != nil &amp;&amp; *podcast.AudioUrl != "", nil</span>
}

// GeneratePodcastUploadURL generates a presigned URL for uploading podcast audio
func (s *podcastService) GeneratePodcastUploadURL(ctx context.Context, podcastID int32) (*UploadURLResponse, error) <span class="cov8" title="1">{
        if s.r2Service == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("R2 service not available")
        }</span>

        // Generate R2 key for podcast audio
        <span class="cov0" title="0">key := fmt.Sprintf("generated/podcasts/podcast_%d_%d.mp3", podcastID, time.Now().Unix())

        // Generate presigned URL for upload
        return s.r2Service.GenerateUploadURLForKey(ctx, key, "audio/mpeg")</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package services

import (
        "bytes"
        "context"
        "fmt"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsconfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/aws/aws-sdk-go-v2/service/s3/types"
        "github.com/google/uuid"
)

type R2Service struct {
        client     *s3.Client
        presigner  *s3.PresignClient
        bucket     string
        accountId  string
        publicHost string
}

type UploadURLResponse struct {
        UploadURL string `json:"upload_url"`
        Key       string `json:"key"`
        PublicURL string `json:"public_url"`
}

type R2Config struct {
        AccessKeyID     string
        SecretAccessKey string
        AccountID       string
        BucketName      string
        PublicHost      string
}

func NewR2Service(cfg R2Config) (*R2Service, error) <span class="cov8" title="1">{
        if cfg.AccessKeyID == "" || cfg.SecretAccessKey == "" || cfg.AccountID == "" || cfg.BucketName == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing required R2 configuration fields")
        }</span>

        // Create AWS configuration
        <span class="cov8" title="1">awsCfg, err := awsconfig.LoadDefaultConfig(context.Background(),
                awsconfig.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(
                        cfg.AccessKeyID,
                        cfg.SecretAccessKey,
                        "",
                )),
                awsconfig.WithRegion("auto"),
                awsconfig.WithEndpointResolverWithOptions(aws.EndpointResolverWithOptionsFunc(
                        func(service, region string, options ...interface{}) (aws.Endpoint, error) </span><span class="cov0" title="0">{
                                return aws.Endpoint{
                                        URL: fmt.Sprintf("https://%s.r2.cloudflarestorage.com", cfg.AccountID),
                                }, nil
                        }</span>)),
        )
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Create S3 client with path-style addressing for R2 compatibility
        <span class="cov8" title="1">client := s3.NewFromConfig(awsCfg, func(o *s3.Options) </span><span class="cov8" title="1">{
                o.UsePathStyle = true
        }</span>)

        <span class="cov8" title="1">return &amp;R2Service{
                client:     client,
                presigner:  s3.NewPresignClient(client),
                bucket:     cfg.BucketName,
                accountId:  cfg.AccountID,
                publicHost: cfg.PublicHost,
        }, nil</span>
}

// GenerateUploadURL generates a presigned URL for uploading a file
func (r *R2Service) GenerateUploadURL(ctx context.Context, contentType string, folder string) (*UploadURLResponse, error) <span class="cov0" title="0">{
        // Generate unique key with folder structure
        var mimeToExt = map[string]string{
                "image/png":       ".png",
                "image/jpeg":      ".jpg",
                "image/jpg":       ".jpg",
                "image/webp":      ".webp",
                "application/pdf": ".pdf",
                "audio/wav":       ".wav",
                "audio/mpeg":      ".mp3",
                "audio/mp3":       ".mp3",
        }
        ext := mimeToExt[contentType] // This will be an empty string for unknown types

        key := fmt.Sprintf("%s/%s%s", folder, uuid.New().String(), ext)

        request := &amp;s3.PutObjectInput{
                Bucket:      aws.String(r.bucket),
                Key:         aws.String(key),
                ContentType: aws.String(contentType),
        }

        // Create presigned URL valid for 15 minutes with CORS headers
        presignResult, err := r.presigner.PresignPutObject(ctx, request,
                func(opts *s3.PresignOptions) </span><span class="cov0" title="0">{
                        opts.Expires = time.Duration(15 * time.Minute)
                }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create presigned URL: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;UploadURLResponse{
                UploadURL: presignResult.URL,
                Key:       key,
                PublicURL: r.GetPublicURL(key),
        }, nil</span>
}

// GetPublicURL returns the public URL for a given key
func (r *R2Service) GetPublicURL(key string) string <span class="cov8" title="1">{
        if r.publicHost != "" </span><span class="cov8" title="1">{
                // Use custom domain if configured
                return fmt.Sprintf("%s/%s", r.publicHost, key)
        }</span>
        // Use R2 public URL
        <span class="cov8" title="1">return fmt.Sprintf("https://pub-%s.r2.dev/%s", r.accountId, key)</span>
}

// DeleteFile deletes a file from R2
func (r *R2Service) DeleteFile(ctx context.Context, key string) error <span class="cov0" title="0">{
        _, err := r.client.DeleteObject(ctx, &amp;s3.DeleteObjectInput{
                Bucket: aws.String(r.bucket),
                Key:    aws.String(key),
        })
        return err
}</span>

// DeleteFiles deletes multiple files from R2
func (r *R2Service) DeleteFiles(ctx context.Context, keys []string) error <span class="cov8" title="1">{
        if len(keys) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">objects := make([]types.ObjectIdentifier, len(keys))
        for i, key := range keys </span><span class="cov0" title="0">{
                objects[i] = types.ObjectIdentifier{
                        Key: aws.String(key),
                }
        }</span>

        <span class="cov0" title="0">_, err := r.client.DeleteObjects(ctx, &amp;s3.DeleteObjectsInput{
                Bucket: aws.String(r.bucket),
                Delete: &amp;types.Delete{
                        Objects: objects,
                },
        })
        return err</span>
}

// ExtractKeyFromURL extracts the key from a public URL
func (r *R2Service) ExtractKeyFromURL(url string) string <span class="cov8" title="1">{
        // Handle custom domain URLs
        if r.publicHost != "" </span><span class="cov8" title="1">{
                prefix := r.publicHost + "/"
                if len(url) &gt;= len(prefix) &amp;&amp; url[:len(prefix)] == prefix </span><span class="cov8" title="1">{
                        return url[len(prefix):]
                }</span>
        }

        // Handle R2 public URL format
        <span class="cov8" title="1">prefix := fmt.Sprintf("https://pub-%s.r2.dev/", r.accountId)
        if len(url) &gt;= len(prefix) &amp;&amp; url[:len(prefix)] == prefix </span><span class="cov8" title="1">{
                return url[len(prefix):]
        }</span>

        // If it doesn't match either format, return the original URL
        // This might be a key already
        <span class="cov8" title="1">return url</span>
}

// GenerateUploadURLForKey generates a presigned URL for a specific key
func (r *R2Service) GenerateUploadURLForKey(ctx context.Context, key string, contentType string) (*UploadURLResponse, error) <span class="cov0" title="0">{
        request := &amp;s3.PutObjectInput{
                Bucket:      aws.String(r.bucket),
                Key:         aws.String(key),
                ContentType: aws.String(contentType),
        }

        // Create presigned URL valid for 15 minutes
        presignResult, err := r.presigner.PresignPutObject(ctx, request,
                func(opts *s3.PresignOptions) </span><span class="cov0" title="0">{
                        opts.Expires = time.Duration(15 * time.Minute)
                }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create presigned URL: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;UploadURLResponse{
                UploadURL: presignResult.URL,
                Key:       key,
                PublicURL: r.GetPublicURL(key),
        }, nil</span>
}

// UploadFile uploads a file directly to R2
func (r *R2Service) UploadFile(ctx context.Context, key string, data []byte, contentType string) (string, error) <span class="cov0" title="0">{
        request := &amp;s3.PutObjectInput{
                Bucket:      aws.String(r.bucket),
                Key:         aws.String(key),
                Body:        bytes.NewReader(data),
                ContentType: aws.String(contentType),
        }

        _, err := r.client.PutObject(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to upload file: %w", err)
        }</span>

        <span class="cov0" title="0">return r.GetPublicURL(key), nil</span>
}

// UploadFileWithMetadata uploads a file with custom metadata
func (r *R2Service) UploadFileWithMetadata(ctx context.Context, key string, data []byte, contentType string, metadata map[string]string) (string, error) <span class="cov0" title="0">{
        metadataAWS := make(map[string]string)
        for k, v := range metadata </span><span class="cov0" title="0">{
                metadataAWS[k] = v
        }</span>

        <span class="cov0" title="0">request := &amp;s3.PutObjectInput{
                Bucket:      aws.String(r.bucket),
                Key:         aws.String(key),
                Body:        bytes.NewReader(data),
                ContentType: aws.String(contentType),
                Metadata:    metadataAWS,
        }

        _, err := r.client.PutObject(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to upload file with metadata: %w", err)
        }</span>

        <span class="cov0" title="0">return r.GetPublicURL(key), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package services

import (
        "strings"

        "github.com/gocolly/colly"
)

type ScrapingService interface {
        Scrape(url string) (string, error)
}

type scrapingService struct{}

func NewScraper() *scrapingService <span class="cov8" title="1">{
        return &amp;scrapingService{}
}</span>

func (s *scrapingService) Scrape(url string) (string, error) <span class="cov8" title="1">{
        c := colly.NewCollector()
        var content strings.Builder

        c.OnHTML("body", func(e *colly.HTMLElement) </span><span class="cov8" title="1">{
                content.WriteString(e.Text)
        }</span>)

        <span class="cov8" title="1">err := c.Visit(url)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return content.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package services

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "os/exec"
        "strings"
        "time"
)

// DialogueInfo contains information about the dialogue being processed
type DialogueInfo struct {
        Index     int    // Dialogue index (1-based)
        Total     int    // Total number of dialogues
        Speaker   string // Speaker name (heart/adam)
        Content   string // Full dialogue content
        RequestID string // FAL API request ID (filled during processing)
}

type SpeechService interface {
        TextToSpeech(prompt string, voice VoiceEnum, speed float64, dialogueInfo *DialogueInfo) (*File, error)
        DownloadAudio(url string) ([]byte, error)
        SaveAudio(data []byte, filename string) error
}

type speechService struct {
        client      *FalClient
        maxAttempts int
        interval    time.Duration
}

func NewSpeechService(falClient *FalClient, maxAttempts int, interval time.Duration) SpeechService <span class="cov8" title="1">{
        return &amp;speechService{
                client:      falClient,
                maxAttempts: maxAttempts,
                interval:    interval,
        }
}</span>

// TextToSpeech converts text to speech using the fal.ai API
func (s *speechService) TextToSpeech(prompt string, voice VoiceEnum, speed float64, dialogueInfo *DialogueInfo) (*File, error) <span class="cov8" title="1">{
        if s.client == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("speech service not configured: FAL_API_KEY not set")
        }</span>

        <span class="cov0" title="0">if voice == "" </span><span class="cov0" title="0">{
                voice = VoiceAfHeart
        }</span>
        <span class="cov0" title="0">if speed == 0 </span><span class="cov0" title="0">{
                speed = 1.0
        }</span>

        // Log dialogue processing start
        <span class="cov0" title="0">if dialogueInfo != nil </span><span class="cov0" title="0">{
                contentPreview := dialogueInfo.Content
                if len(contentPreview) &gt; 50 </span><span class="cov0" title="0">{
                        contentPreview = contentPreview[:50] + "..."
                }</span>
                <span class="cov0" title="0">log.Printf("Processing dialogue %d/%d: \"%s\" [speaker: %s]",
                        dialogueInfo.Index, dialogueInfo.Total, contentPreview, dialogueInfo.Speaker)</span>
        }

        <span class="cov0" title="0">req := EnglishRequest{
                Prompt: prompt,
                Voice:  voice,
                Speed:  speed,
        }

        result, err := s.client.submitAndWait(req, s.maxAttempts, s.interval, dialogueInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate speech: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;result.Audio, nil</span>
}

// DownloadAudio downloads audio data from a URL
func (s *speechService) DownloadAudio(url string) ([]byte, error) <span class="cov8" title="1">{
        if s.client == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("speech service not configured: FAL_API_KEY not set")
        }</span>
        <span class="cov0" title="0">return s.client.downloadAudioFile(url)</span>
}

// SaveAudio saves audio data to a file
func (s *speechService) SaveAudio(data []byte, filename string) error <span class="cov8" title="1">{
        return os.WriteFile(filename, data, 0644)
}</span>

// VoiceEnum represents available voice options for the API
type VoiceEnum string

const (
        VoiceAfHeart   VoiceEnum = "af_heart"
        VoiceAfAlloy   VoiceEnum = "af_alloy"
        VoiceAfAoede   VoiceEnum = "af_aoede"
        VoiceAfBella   VoiceEnum = "af_bella"
        VoiceAfJessica VoiceEnum = "af_jessica"
        VoiceAfKore    VoiceEnum = "af_kore"
        VoiceAfNicole  VoiceEnum = "af_nicole"
        VoiceAfNova    VoiceEnum = "af_nova"
        VoiceAfRiver   VoiceEnum = "af_river"
        VoiceAfSarah   VoiceEnum = "af_sarah"
        VoiceAfSky     VoiceEnum = "af_sky"
        VoiceAmAdam    VoiceEnum = "am_adam"
        VoiceAmEcho    VoiceEnum = "am_echo"
        VoiceAmEric    VoiceEnum = "am_adam"
        VoiceAmFenrir  VoiceEnum = "am_fenrir"
        VoiceAmLiam    VoiceEnum = "am_liam"
        VoiceAmMichael VoiceEnum = "am_michael"
        VoiceAmOnyx    VoiceEnum = "am_onyx"
        VoiceAmPuck    VoiceEnum = "am_puck"
        VoiceAmSanta   VoiceEnum = "am_santa"
)

// File represents a file response from the API
type File struct {
        URL         string `json:"url"`
        ContentType string `json:"content_type"`
        FileName    string `json:"file_name"`
        FileSize    int64  `json:"file_size"`
        FileData    string `json:"file_data"`
}

// EnglishRequest represents a request for English text-to-speech
type EnglishRequest struct {
        Prompt string    `json:"prompt"`
        Voice  VoiceEnum `json:"voice"`
        Speed  float64   `json:"speed"`
}

// RequestResponse represents the initial response when submitting a request
type RequestResponse struct {
        RequestID string `json:"request_id"`
        Status    string `json:"status"`
        Message   string `json:"message"`
}

// StatusResponse represents the status of a request
type StatusResponse struct {
        RequestID string `json:"request_id"`
        Status    string `json:"status"`
        Message   string `json:"message"`
        Progress  int    `json:"progress"`
}

// ResultResponse represents the final result of a request
type ResultResponse struct {
        RequestID string `json:"request_id"`
        Status    string `json:"status"`
        Audio     File   `json:"audio"`
}

// FalClient represents a client for interacting with the fal.ai API
type FalClient struct {
        apiKey     string
        baseURL    string
        httpClient *http.Client
}

// NewFalClient creates a new FalClient instance
func NewFalClient(apiKey string) *FalClient <span class="cov8" title="1">{
        return &amp;FalClient{
                apiKey:  apiKey,
                baseURL: "https://queue.fal.run",
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }
}</span>

// APIError represents an error response from the API
type APIError struct {
        StatusCode int
        Message    string
}

func (e *APIError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("API error (status %d): %s", e.StatusCode, e.Message)
}</span>

// makeRequest makes an HTTP request to the fal.ai API
func (c *FalClient) makeRequest(method, url string, body any) (*http.Response, error) <span class="cov8" title="1">{
        var reqBody io.Reader
        if body != nil </span><span class="cov8" title="1">{
                jsonData, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov8" title="1">reqBody = bytes.NewReader(jsonData)</span>
        }

        <span class="cov8" title="1">req, err := http.NewRequest(method, url, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Authorization", "Key "+c.apiKey)
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>

        <span class="cov8" title="1">if resp.StatusCode &gt;= 400 </span><span class="cov8" title="1">{
                defer resp.Body.Close()
                body, _ := io.ReadAll(resp.Body)
                return nil, &amp;APIError{
                        StatusCode: resp.StatusCode,
                        Message:    string(body),
                }
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

// submitEnglishRequest submits a text-to-speech request for English text
func (c *FalClient) submitEnglishRequest(req EnglishRequest) (*RequestResponse, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/fal-ai/kokoro/american-english", c.baseURL)
        resp, err := c.makeRequest("POST", url, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        var result RequestResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// getRequestStatus checks the status of a request
func (c *FalClient) getRequestStatus(requestID string) (*StatusResponse, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/fal-ai/kokoro/requests/%s/status", c.baseURL, requestID)
        resp, err := c.makeRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        var result StatusResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode status response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// getRequestResult retrieves the final result of a completed request
func (c *FalClient) getRequestResult(requestID string) (*ResultResponse, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/fal-ai/kokoro/requests/%s", c.baseURL, requestID)
        resp, err := c.makeRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        var result ResultResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode result response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// waitForResult waits for a request to complete and returns the result (polls indefinitely until COMPLETED or FAILED)
func (c *FalClient) waitForResult(requestID string, interval time.Duration, dialogueInfo *DialogueInfo) (*ResultResponse, error) <span class="cov8" title="1">{
        startTime := time.Now()
        attempt := 0

        for </span><span class="cov8" title="1">{
                attempt++
                status, err := c.getRequestStatus(requestID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Build enhanced status message with dialogue context
                <span class="cov8" title="1">var statusMsg strings.Builder
                if dialogueInfo != nil </span><span class="cov8" title="1">{
                        statusMsg.WriteString(fmt.Sprintf("Dialogue %d/%d [req:%s] - ",
                                dialogueInfo.Index, dialogueInfo.Total, requestID[:8]))
                }</span>
                <span class="cov8" title="1">statusMsg.WriteString(fmt.Sprintf("Status check %d: %s", attempt, status.Status))

                if status.Progress &gt; 0 </span><span class="cov8" title="1">{
                        statusMsg.WriteString(fmt.Sprintf(" (%d%%)", status.Progress))
                }</span>

                // Log status for concurrent processing visibility
                <span class="cov8" title="1">log.Print(statusMsg.String())

                switch status.Status </span>{
                case "COMPLETED":<span class="cov8" title="1">
                        duration := time.Since(startTime)
                        if dialogueInfo != nil </span><span class="cov8" title="1">{
                                log.Printf("Dialogue %d/%d completed after %d attempts (%.1fs)",
                                        dialogueInfo.Index, dialogueInfo.Total, attempt, duration.Seconds())
                        }</span>
                        <span class="cov8" title="1">return c.getRequestResult(requestID)</span>
                case "FAILED":<span class="cov8" title="1">
                        return nil, fmt.Errorf("request failed: %s", status.Message)</span>
                case "IN_PROGRESS", "QUEUED", "IN_QUEUE":<span class="cov8" title="1">
                        log.Printf("Dialogue %d/%d still processing, will continue polling...",
                                dialogueInfo.Index, dialogueInfo.Total)
                        time.Sleep(interval)
                        continue</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("unknown status: %s", status.Status)</span>
                }
        }
}

// submitAndWait submits a request and waits for it to complete
func (c *FalClient) submitAndWait(req EnglishRequest, maxAttempts int, interval time.Duration, dialogueInfo *DialogueInfo) (*ResultResponse, error) <span class="cov8" title="1">{
        submitResp, err := c.submitEnglishRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to submit request: %w", err)
        }</span>

        // Store the request ID in dialogue info for logging
        <span class="cov8" title="1">if dialogueInfo != nil </span><span class="cov0" title="0">{
                dialogueInfo.RequestID = submitResp.RequestID
        }</span>

        // Note: maxAttempts is now ignored - we'll poll indefinitely until COMPLETED or FAILED
        <span class="cov8" title="1">return c.waitForResult(submitResp.RequestID, interval, dialogueInfo)</span>
}

// WithRetry adds retry logic to any operation
func WithRetry(operation func() error, maxAttempts int, backoff time.Duration) error <span class="cov8" title="1">{
        var lastErr error

        for i := 0; i &lt; maxAttempts; i++ </span><span class="cov8" title="1">{
                err := operation()
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">lastErr = err

                // Don't wait on the last attempt
                if i &lt; maxAttempts-1 </span><span class="cov8" title="1">{
                        time.Sleep(backoff * time.Duration(i+1))
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("operation failed after %d attempts, last error: %w", maxAttempts, lastErr)</span>
}

// downloadAudioFile downloads an audio file from the given URL
func (c *FalClient) downloadAudioFile(url string) ([]byte, error) <span class="cov8" title="1">{
        resp, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to download audio file: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to download audio file, status: %s", resp.Status)
        }</span>

        <span class="cov8" title="1">return io.ReadAll(resp.Body)</span>
}

// CreateEnglishRequest creates a new English request with default values
func CreateEnglishRequest(prompt string, voice VoiceEnum, speed float64) EnglishRequest <span class="cov8" title="1">{
        if voice == "" </span><span class="cov8" title="1">{
                voice = VoiceAfHeart
        }</span>
        <span class="cov8" title="1">if speed == 0 </span><span class="cov8" title="1">{
                speed = 1.0
        }</span>
        <span class="cov8" title="1">return EnglishRequest{
                Prompt: prompt,
                Voice:  voice,
                Speed:  speed,
        }</span>
}

// StitchAudioFiles combines multiple audio files into a single file using ffmpeg
func StitchAudioFiles(inputFiles []string, outputFile string) error <span class="cov0" title="0">{
        if len(inputFiles) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no input files provided")
        }</span>

        // Log the files being stitched for debugging
        <span class="cov0" title="0">log.Printf("Stitching %d audio files (converting WAV to MP3): %v", len(inputFiles), inputFiles)

        // Create a temporary file list for ffmpeg
        listFile, err := os.CreateTemp("", "audio_list_*.txt")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp file: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(listFile.Name())
        defer listFile.Close()

        // Write file list in ffmpeg format
        for _, file := range inputFiles </span><span class="cov0" title="0">{
                // Verify file exists before adding to list
                if _, err := os.Stat(file); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("audio file does not exist: %s - %w", file, err)
                }</span>
                <span class="cov0" title="0">if _, err := listFile.WriteString(fmt.Sprintf("file '%s'\n", file)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write to list file: %w", err)
                }</span>
        }

        // Ensure the list file is properly written
        <span class="cov0" title="0">if err := listFile.Sync(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sync list file: %w", err)
        }</span>

        // Build ffmpeg command - re-encode to MP3 since FAL returns WAV format
        // Using libmp3lame codec with 192k bitrate for good quality
        // Key changes from original:
        // - Changed "-c copy" to "-c:a libmp3lame -b:a 192k" to re-encode WAV to MP3
        // - This resolves the format mismatch issue
        <span class="cov0" title="0">cmd := exec.Command("ffmpeg", "-y", "-f", "concat", "-safe", "0", "-i", listFile.Name(), "-c:a", "libmp3lame", "-b:a", "192k", outputFile)

        // Run the command
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ffmpeg command failed: %w\nOutput: %s", err, string(output))
        }</span>

        // Verify output file was created
        <span class="cov0" title="0">if _, err := os.Stat(outputFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("output file was not created: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully stitched %d audio files into %s (WAV to MP3 conversion)", len(inputFiles), outputFile)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "sync"
        "time"
)

// SSEMessage represents a message sent via Server-Sent Events
type SSEMessage struct {
        Event string      `json:"event"`
        Data  interface{} `json:"data"`
}

// ItemUpdateEvent represents an item update notification
type ItemUpdateEvent struct {
        ItemID           int32   `json:"item_id"`
        ProcessingStatus *string `json:"processing_status"`
        UpdateType       string  `json:"update_type"` // "created", "updated", "completed", "failed"
}

// PodcastUpdateEvent represents a podcast update notification
type PodcastUpdateEvent struct {
        PodcastID  int32  `json:"podcast_id"`
        Status     string `json:"status"`
        UpdateType string `json:"update_type"` // "created", "writing", "generating", "completed", "failed"
}

// SSEClient represents a single SSE connection
type SSEClient struct {
        UserID  int32
        Channel chan SSEMessage
}

// SSEManager manages SSE connections for multiple users
type SSEManager struct {
        clients map[int32][]*SSEClient
        mu      sync.RWMutex
}

// NewSSEManager creates a new SSE manager
func NewSSEManager() *SSEManager <span class="cov8" title="1">{
        return &amp;SSEManager{
                clients: make(map[int32][]*SSEClient),
        }
}</span>

// AddClient adds a new SSE client for a user
func (m *SSEManager) AddClient(userID int32) *SSEClient <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        client := &amp;SSEClient{
                UserID:  userID,
                Channel: make(chan SSEMessage, 10), // Buffer to prevent blocking
        }

        m.clients[userID] = append(m.clients[userID], client)
        log.Printf("SSE: Added client for user %d (total: %d)", userID, len(m.clients[userID]))

        return client
}</span>

// RemoveClient removes an SSE client
func (m *SSEManager) RemoveClient(client *SSEClient) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        userClients := m.clients[client.UserID]
        for i, c := range userClients </span><span class="cov8" title="1">{
                if c == client </span><span class="cov8" title="1">{
                        // Remove client from slice
                        m.clients[client.UserID] = append(userClients[:i], userClients[i+1:]...)
                        close(client.Channel)
                        log.Printf("SSE: Removed client for user %d (remaining: %d)", client.UserID, len(m.clients[client.UserID]))
                        break</span>
                }
        }

        // Clean up empty user entries
        <span class="cov8" title="1">if len(m.clients[client.UserID]) == 0 </span><span class="cov8" title="1">{
                delete(m.clients, client.UserID)
        }</span>
}

// BroadcastToUser sends a message to all clients for a specific user
func (m *SSEManager) BroadcastToUser(userID int32, message SSEMessage) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        clients := m.clients[userID]
        if len(clients) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">log.Printf("SSE: Broadcasting to %d clients for user %d: %s", len(clients), userID, message.Event)

        for _, client := range clients </span><span class="cov8" title="1">{
                select </span>{
                case client.Channel &lt;- message:<span class="cov8" title="1"></span>
                        // Message sent successfully
                case &lt;-time.After(1 * time.Second):<span class="cov0" title="0">
                        // Client is not reading, skip (prevents blocking)
                        log.Printf("SSE: Client for user %d is slow, skipping message", userID)</span>
                }
        }
}

// NotifyItemUpdate notifies all clients for a user about an item update
func (m *SSEManager) NotifyItemUpdate(userID int32, itemID int32, processingStatus *string, updateType string) <span class="cov8" title="1">{
        event := ItemUpdateEvent{
                ItemID:           itemID,
                ProcessingStatus: processingStatus,
                UpdateType:       updateType,
        }

        message := SSEMessage{
                Event: "item-update",
                Data:  event,
        }

        m.BroadcastToUser(userID, message)
}</span>

// NotifyPodcastUpdate notifies all clients for a user about a podcast update
func (m *SSEManager) NotifyPodcastUpdate(userID int32, podcastID int32, status string, updateType string) <span class="cov8" title="1">{
        event := PodcastUpdateEvent{
                PodcastID:  podcastID,
                Status:     status,
                UpdateType: updateType,
        }

        message := SSEMessage{
                Event: "podcast-update",
                Data:  event,
        }

        m.BroadcastToUser(userID, message)
}</span>

// WriteSSEMessage writes a SSE message to a channel with proper formatting
func WriteSSEMessage(ctx context.Context, client *SSEClient, writer chan&lt;- string) <span class="cov8" title="1">{
        // Send initial comment to establish connection
        writer &lt;- ": connected\n\n"

        // Send keepalive ping every 30 seconds
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Send keepalive comment
                        writer &lt;- ": keepalive\n\n"</span>
                case msg, ok := &lt;-client.Channel:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // Marshal data to JSON
                        <span class="cov8" title="1">data, err := json.Marshal(msg.Data)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("SSE: Error marshaling message: %v", err)
                                continue</span>
                        }

                        // Format SSE message
                        <span class="cov8" title="1">if msg.Event != "" </span><span class="cov8" title="1">{
                                writer &lt;- fmt.Sprintf("event: %s\n", msg.Event)
                        }</span>
                        <span class="cov8" title="1">writer &lt;- fmt.Sprintf("data: %s\n\n", string(data))</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package services

import (
        "context"

        "github.com/yamirghofran/briefbot/internal/db"
)

type UserService interface {
        CreateUser(ctx context.Context, name, email, authProvider, oauthID, passwordHash *string) (*db.User, error)
        GetUser(ctx context.Context, id int32) (*db.User, error)
        GetUserByEmail(ctx context.Context, email *string) (*db.User, error)
        ListUsers(ctx context.Context) ([]db.User, error)
        UpdateUser(ctx context.Context, id int32, name, email, authProvider, oauthID, passwordHash *string) error
        DeleteUser(ctx context.Context, id int32) error
}

type userService struct {
        querier db.Querier
}

func NewUserService(querier db.Querier) UserService <span class="cov8" title="1">{
        return &amp;userService{querier: querier}
}</span>

func (s *userService) CreateUser(ctx context.Context, name, email, authProvider, oauthID, passwordHash *string) (*db.User, error) <span class="cov8" title="1">{
        params := db.CreateUserParams{
                Name:         name,
                Email:        email,
                AuthProvider: authProvider,
                OauthID:      oauthID,
                PasswordHash: passwordHash,
        }
        user, err := s.querier.CreateUser(ctx, params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (s *userService) GetUser(ctx context.Context, id int32) (*db.User, error) <span class="cov8" title="1">{
        user, err := s.querier.GetUser(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (s *userService) GetUserByEmail(ctx context.Context, email *string) (*db.User, error) <span class="cov8" title="1">{
        user, err := s.querier.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (s *userService) ListUsers(ctx context.Context) ([]db.User, error) <span class="cov8" title="1">{
        users, err := s.querier.ListUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return users, nil</span>
}

func (s *userService) UpdateUser(ctx context.Context, id int32, name, email, authProvider, oauthID, passwordHash *string) error <span class="cov8" title="1">{
        params := db.UpdateUserParams{
                ID:           id,
                Name:         name,
                Email:        email,
                AuthProvider: authProvider,
                OauthID:      oauthID,
                PasswordHash: passwordHash,
        }
        return s.querier.UpdateUser(ctx, params)
}</span>

func (s *userService) DeleteUser(ctx context.Context, id int32) error <span class="cov8" title="1">{
        return s.querier.DeleteUser(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package services

import (
        "context"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/yamirghofran/briefbot/internal/db"
)

type WorkerService interface {
        Start(ctx context.Context) error
        Stop() error
        IsRunning() bool
}

type workerService struct {
        jobQueueService JobQueueService
        aiService       AIService
        scrapingService ScrapingService
        podcastService  PodcastService

        // Configuration
        workerCount    int
        pollInterval   time.Duration
        maxRetries     int
        batchSize      int32
        enablePodcasts bool

        // Runtime state
        wg        sync.WaitGroup
        ctx       context.Context
        cancel    context.CancelFunc
        running   bool
        runningMu sync.Mutex
}

type WorkerConfig struct {
        WorkerCount    int
        PollInterval   time.Duration
        MaxRetries     int
        BatchSize      int32
        EnablePodcasts bool
}

func NewWorkerService(
        jobQueueService JobQueueService,
        aiService AIService,
        scrapingService ScrapingService,
        podcastService PodcastService,
        config WorkerConfig,
) WorkerService <span class="cov8" title="1">{
        if config.WorkerCount &lt;= 0 </span><span class="cov8" title="1">{
                config.WorkerCount = 2
        }</span>
        <span class="cov8" title="1">if config.PollInterval &lt;= 0 </span><span class="cov8" title="1">{
                config.PollInterval = 5 * time.Second
        }</span>
        <span class="cov8" title="1">if config.MaxRetries &lt;= 0 </span><span class="cov8" title="1">{
                config.MaxRetries = 3
        }</span>
        <span class="cov8" title="1">if config.BatchSize &lt;= 0 </span><span class="cov8" title="1">{
                config.BatchSize = 10
        }</span>

        <span class="cov8" title="1">return &amp;workerService{
                jobQueueService: jobQueueService,
                aiService:       aiService,
                scrapingService: scrapingService,
                podcastService:  podcastService,
                workerCount:     config.WorkerCount,
                pollInterval:    config.PollInterval,
                maxRetries:      config.MaxRetries,
                batchSize:       config.BatchSize,
                enablePodcasts:  config.EnablePodcasts,
        }</span>
}

func (s *workerService) Start(ctx context.Context) error <span class="cov8" title="1">{
        s.runningMu.Lock()
        if s.running </span><span class="cov8" title="1">{
                s.runningMu.Unlock()
                return fmt.Errorf("worker service is already running")
        }</span>
        <span class="cov8" title="1">s.runningMu.Unlock()

        s.ctx, s.cancel = context.WithCancel(ctx)

        // Start worker goroutines
        for i := 0; i &lt; s.workerCount; i++ </span><span class="cov8" title="1">{
                s.wg.Add(1)
                go s.worker(i + 1)
        }</span>

        <span class="cov8" title="1">s.runningMu.Lock()
        s.running = true
        s.runningMu.Unlock()

        log.Printf("Worker service started with %d workers", s.workerCount)
        return nil</span>
}

func (s *workerService) Stop() error <span class="cov8" title="1">{
        s.runningMu.Lock()
        if !s.running </span><span class="cov8" title="1">{
                s.runningMu.Unlock()
                return fmt.Errorf("worker service is not running")
        }</span>
        <span class="cov8" title="1">s.runningMu.Unlock()

        log.Println("Stopping worker service...")
        s.cancel()
        s.wg.Wait()

        s.runningMu.Lock()
        s.running = false
        s.runningMu.Unlock()

        log.Println("Worker service stopped")
        return nil</span>
}

func (s *workerService) IsRunning() bool <span class="cov8" title="1">{
        s.runningMu.Lock()
        defer s.runningMu.Unlock()
        return s.running
}</span>

func (s *workerService) worker(id int) <span class="cov8" title="1">{
        defer s.wg.Done()

        log.Printf("Worker %d started", id)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-s.ctx.Done():<span class="cov8" title="1">
                        log.Printf("Worker %d stopping", id)
                        return</span>
                default:<span class="cov0" title="0">
                        // Process a batch of items
                        if err := s.processBatch(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Worker %d error processing batch: %v", id, err)
                        }</span>

                        // Wait before next poll
                        <span class="cov0" title="0">select </span>{
                        case &lt;-s.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(s.pollInterval):<span class="cov0" title="0"></span>
                                // Continue to next iteration
                        }
                }
        }
}

// Code smell: hardcoded worker service (OCP violation)
// Solution: Strategy pattern

// func (s *workerService) processBatch() error {
//         // Process items first
//         if err := s.processItemBatch(); err != nil {
//                 return fmt.Errorf("failed to process item batch: %w", err)
//         }

//         // Process podcasts if enabled
//         if s.enablePodcasts &amp;&amp; s.podcastService != nil {
//                 if err := s.processPodcastBatch(); err != nil {
//                         return fmt.Errorf("failed to process podcast batch: %w", err)
//                 }
//         }

//         return nil
// }

func (s *workerService) processBatch() error <span class="cov8" title="1">{
        // Process items first
        if err := s.processItemBatch(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process item batch: %w", err)
        }</span>

        // Process podcasts if enabled
        <span class="cov8" title="1">if s.enablePodcasts &amp;&amp; s.podcastService != nil </span><span class="cov8" title="1">{
                if err := s.processPodcastBatch(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to process podcast batch: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *workerService) processItemBatch() error <span class="cov8" title="1">{
        // Get pending items
        items, err := s.jobQueueService.DequeuePendingItems(s.ctx, s.batchSize)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to dequeue items: %w", err)
        }</span>

        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov8" title="1">{
                // No items to process, sleep longer
                time.Sleep(s.pollInterval)
                return nil
        }</span>

        <span class="cov8" title="1">log.Printf("Processing batch of %d items", len(items))

        // Process each item
        for _, item := range items </span><span class="cov8" title="1">{
                if err := s.processItem(s.ctx, item); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to process item %d: %v", item.ID, err)
                        // Continue with next item even if one fails
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *workerService) processItem(ctx context.Context, item db.Item) error <span class="cov8" title="1">{
        // Mark item as processing
        if err := s.jobQueueService.MarkItemAsProcessing(ctx, item.ID); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to mark item as processing: %w", err)
        }</span>

        <span class="cov8" title="1">log.Printf("Processing item %d: %s", item.ID, *item.Url)

        // Process the URL with retry logic
        var textContent string
        var extraction ItemExtraction
        var summary string
        var err error

        // Retry processing up to maxRetries times
        for attempt := 1; attempt &lt;= s.maxRetries; attempt++ </span><span class="cov8" title="1">{
                textContent, extraction, summary, err = s.processURL(ctx, *item.Url)
                if err == nil </span><span class="cov8" title="1">{
                        break</span> // Success!
                }

                <span class="cov8" title="1">log.Printf("Attempt %d failed for item %d: %v", attempt, item.ID, err)

                if attempt &lt; s.maxRetries </span><span class="cov8" title="1">{
                        // Wait before retry with exponential backoff
                        backoffDuration := time.Duration(attempt) * time.Second
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        case &lt;-time.After(backoffDuration):<span class="cov8" title="1"></span>
                                // Continue to next attempt
                        }
                }
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // All retries failed, mark as failed
                errorMsg := fmt.Sprintf("Failed after %d attempts: %v", s.maxRetries, err)
                if failErr := s.jobQueueService.FailItem(ctx, item.ID, errorMsg); failErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to mark item %d as failed: %v", item.ID, failErr)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("failed to process URL after %d attempts: %w", s.maxRetries, err)</span>
        }

        // Mark as completed with AI-extracted title
        <span class="cov8" title="1">if err := s.jobQueueService.CompleteItem(ctx, item.ID, extraction.Title, textContent, summary, extraction.Type, extraction.Platform, extraction.Tags, extraction.Authors); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to complete item: %w", err)
        }</span>

        <span class="cov8" title="1">log.Printf("Successfully processed item %d", item.ID)
        return nil</span>
}

func (s *workerService) processURL(ctx context.Context, url string) (string, ItemExtraction, string, error) <span class="cov8" title="1">{
        // Scrape content
        content, err := s.scrapingService.Scrape(url)
        if err != nil </span><span class="cov8" title="1">{
                return "", ItemExtraction{}, "", fmt.Errorf("failed to scrape URL: %w", err)
        }</span>

        // Extract metadata
        <span class="cov8" title="1">extraction, err := s.aiService.ExtractContent(ctx, content)
        if err != nil </span><span class="cov8" title="1">{
                return "", ItemExtraction{}, "", fmt.Errorf("failed to extract content: %w", err)
        }</span>

        // Summarize content
        <span class="cov8" title="1">summary, err := s.aiService.SummarizeContent(ctx, content)
        if err != nil </span><span class="cov8" title="1">{
                return "", ItemExtraction{}, "", fmt.Errorf("failed to summarize content: %w", err)
        }</span>

        // Concatenate summary
        <span class="cov8" title="1">concatenatedSummary := ConcatenateSummary(summary)

        return content, extraction, concatenatedSummary, nil</span>
}

func (s *workerService) processPodcastBatch() error <span class="cov8" title="1">{
        // Get pending podcasts with atomic acquisition to prevent multiple workers from processing the same podcast
        pendingPodcasts, err := s.podcastService.AcquirePendingPodcasts(s.ctx, s.batchSize)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to acquire pending podcasts: %w", err)
        }</span>

        <span class="cov8" title="1">if len(pendingPodcasts) == 0 </span><span class="cov8" title="1">{
                // No podcasts to process, sleep longer
                time.Sleep(s.pollInterval)
                return nil
        }</span>

        <span class="cov8" title="1">log.Printf("Processing batch of %d podcasts", len(pendingPodcasts))

        // Process each podcast
        for _, podcast := range pendingPodcasts </span><span class="cov8" title="1">{
                if err := s.processPodcast(s.ctx, podcast); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to process podcast %d: %v", podcast.ID, err)
                        // Continue with next podcast even if one fails
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *workerService) processPodcast(ctx context.Context, podcast db.Podcast) error <span class="cov8" title="1">{
        log.Printf("Processing podcast %d: %s", podcast.ID, podcast.Title)

        // Process the podcast with retry logic
        var err error

        // Retry processing up to maxRetries times
        for attempt := 1; attempt &lt;= s.maxRetries; attempt++ </span><span class="cov8" title="1">{
                err = s.podcastService.ProcessPodcast(ctx, podcast.ID)
                if err == nil </span><span class="cov8" title="1">{
                        break</span> // Success!
                }

                <span class="cov8" title="1">log.Printf("Attempt %d failed for podcast %d: %v", attempt, podcast.ID, err)

                if attempt &lt; s.maxRetries </span><span class="cov8" title="1">{
                        // Wait before retry with exponential backoff
                        backoffDuration := time.Duration(attempt) * time.Second
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        case &lt;-time.After(backoffDuration):<span class="cov8" title="1"></span>
                                // Continue to next attempt
                        }
                }
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // All retries failed, mark as failed
                if failErr := s.podcastService.UpdatePodcastStatus(ctx, podcast.ID, PodcastStatusFailed); failErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to mark podcast %d as failed: %v", podcast.ID, failErr)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("failed to process podcast after %d attempts: %w", s.maxRetries, err)</span>
        }

        <span class="cov8" title="1">log.Printf("Successfully processed podcast %d", podcast.ID)
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
