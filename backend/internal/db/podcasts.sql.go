// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: podcasts.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addItemToPodcast = `-- name: AddItemToPodcast :one
INSERT INTO podcast_items (podcast_id, item_id, item_order) VALUES ($1, $2, $3) RETURNING id, podcast_id, item_id, item_order, created_at
`

type AddItemToPodcastParams struct {
	PodcastID *int32 `json:"podcast_id"`
	ItemID    *int32 `json:"item_id"`
	ItemOrder int32  `json:"item_order"`
}

func (q *Queries) AddItemToPodcast(ctx context.Context, arg AddItemToPodcastParams) (PodcastItem, error) {
	row := q.db.QueryRow(ctx, addItemToPodcast, arg.PodcastID, arg.ItemID, arg.ItemOrder)
	var i PodcastItem
	err := row.Scan(
		&i.ID,
		&i.PodcastID,
		&i.ItemID,
		&i.ItemOrder,
		&i.CreatedAt,
	)
	return i, err
}

const clearPodcastItems = `-- name: ClearPodcastItems :exec
DELETE FROM podcast_items WHERE podcast_id = $1
`

func (q *Queries) ClearPodcastItems(ctx context.Context, podcastID *int32) error {
	_, err := q.db.Exec(ctx, clearPodcastItems, podcastID)
	return err
}

const countPodcastItems = `-- name: CountPodcastItems :one
SELECT COUNT(*) FROM podcast_items WHERE podcast_id = $1
`

func (q *Queries) CountPodcastItems(ctx context.Context, podcastID *int32) (int64, error) {
	row := q.db.QueryRow(ctx, countPodcastItems, podcastID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPodcast = `-- name: CreatePodcast :one
INSERT INTO podcasts (user_id, title, description, status) VALUES ($1, $2, $3, $4) RETURNING id, user_id, title, description, status, audio_url, dialogues, duration_seconds, created_at, updated_at, completed_at
`

type CreatePodcastParams struct {
	UserID      *int32  `json:"user_id"`
	Title       string  `json:"title"`
	Description *string `json:"description"`
	Status      string  `json:"status"`
}

func (q *Queries) CreatePodcast(ctx context.Context, arg CreatePodcastParams) (Podcast, error) {
	row := q.db.QueryRow(ctx, createPodcast,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.Status,
	)
	var i Podcast
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.AudioUrl,
		&i.Dialogues,
		&i.DurationSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createPodcastWithDialogues = `-- name: CreatePodcastWithDialogues :one
INSERT INTO podcasts (user_id, title, description, status, dialogues) VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, description, status, audio_url, dialogues, duration_seconds, created_at, updated_at, completed_at
`

type CreatePodcastWithDialoguesParams struct {
	UserID      *int32  `json:"user_id"`
	Title       string  `json:"title"`
	Description *string `json:"description"`
	Status      string  `json:"status"`
	Dialogues   []byte  `json:"dialogues"`
}

func (q *Queries) CreatePodcastWithDialogues(ctx context.Context, arg CreatePodcastWithDialoguesParams) (Podcast, error) {
	row := q.db.QueryRow(ctx, createPodcastWithDialogues,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.Dialogues,
	)
	var i Podcast
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.AudioUrl,
		&i.Dialogues,
		&i.DurationSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const deletePodcast = `-- name: DeletePodcast :exec
DELETE FROM podcasts WHERE id = $1
`

func (q *Queries) DeletePodcast(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePodcast, id)
	return err
}

const getCompletedPodcasts = `-- name: GetCompletedPodcasts :many
SELECT id, user_id, title, description, status, audio_url, dialogues, duration_seconds, created_at, updated_at, completed_at FROM podcasts WHERE status = 'completed' ORDER BY created_at DESC LIMIT $1
`

func (q *Queries) GetCompletedPodcasts(ctx context.Context, limit int32) ([]Podcast, error) {
	rows, err := q.db.Query(ctx, getCompletedPodcasts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Podcast{}
	for rows.Next() {
		var i Podcast
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.AudioUrl,
			&i.Dialogues,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingPodcasts = `-- name: GetPendingPodcasts :many
SELECT id, user_id, title, description, status, audio_url, dialogues, duration_seconds, created_at, updated_at, completed_at FROM podcasts 
WHERE status = 'pending' 
ORDER BY created_at ASC 
LIMIT $1
FOR UPDATE SKIP LOCKED
`

func (q *Queries) GetPendingPodcasts(ctx context.Context, limit int32) ([]Podcast, error) {
	rows, err := q.db.Query(ctx, getPendingPodcasts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Podcast{}
	for rows.Next() {
		var i Podcast
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.AudioUrl,
			&i.Dialogues,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPodcast = `-- name: GetPodcast :one
SELECT id, user_id, title, description, status, audio_url, dialogues, duration_seconds, created_at, updated_at, completed_at FROM podcasts WHERE id = $1
`

func (q *Queries) GetPodcast(ctx context.Context, id int32) (Podcast, error) {
	row := q.db.QueryRow(ctx, getPodcast, id)
	var i Podcast
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.AudioUrl,
		&i.Dialogues,
		&i.DurationSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getPodcastByUser = `-- name: GetPodcastByUser :many
SELECT id, user_id, title, description, status, audio_url, dialogues, duration_seconds, created_at, updated_at, completed_at FROM podcasts WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetPodcastByUser(ctx context.Context, userID *int32) ([]Podcast, error) {
	rows, err := q.db.Query(ctx, getPodcastByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Podcast{}
	for rows.Next() {
		var i Podcast
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.AudioUrl,
			&i.Dialogues,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPodcastItemIDs = `-- name: GetPodcastItemIDs :many
SELECT item_id FROM podcast_items WHERE podcast_id = $1 ORDER BY item_order ASC
`

func (q *Queries) GetPodcastItemIDs(ctx context.Context, podcastID *int32) ([]*int32, error) {
	rows, err := q.db.Query(ctx, getPodcastItemIDs, podcastID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*int32{}
	for rows.Next() {
		var item_id *int32
		if err := rows.Scan(&item_id); err != nil {
			return nil, err
		}
		items = append(items, item_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPodcastItems = `-- name: GetPodcastItems :many
SELECT items.id, items.user_id, items.url, items.is_read, items.text_content, items.summary, items.type, items.tags, items.platform, items.authors, items.created_at, items.modified_at, items.title, items.processing_status, items.processing_error, podcast_items.item_order 
FROM items 
JOIN podcast_items ON items.id = podcast_items.item_id 
WHERE podcast_items.podcast_id = $1 
ORDER BY podcast_items.item_order ASC
`

type GetPodcastItemsRow struct {
	ID               int32      `json:"id"`
	UserID           *int32     `json:"user_id"`
	Url              *string    `json:"url"`
	IsRead           *bool      `json:"is_read"`
	TextContent      *string    `json:"text_content"`
	Summary          *string    `json:"summary"`
	Type             *string    `json:"type"`
	Tags             []string   `json:"tags"`
	Platform         *string    `json:"platform"`
	Authors          []string   `json:"authors"`
	CreatedAt        *time.Time `json:"created_at"`
	ModifiedAt       *time.Time `json:"modified_at"`
	Title            string     `json:"title"`
	ProcessingStatus *string    `json:"processing_status"`
	ProcessingError  *string    `json:"processing_error"`
	ItemOrder        int32      `json:"item_order"`
}

func (q *Queries) GetPodcastItems(ctx context.Context, podcastID *int32) ([]GetPodcastItemsRow, error) {
	rows, err := q.db.Query(ctx, getPodcastItems, podcastID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPodcastItemsRow{}
	for rows.Next() {
		var i GetPodcastItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.IsRead,
			&i.TextContent,
			&i.Summary,
			&i.Type,
			&i.Tags,
			&i.Platform,
			&i.Authors,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.Title,
			&i.ProcessingStatus,
			&i.ProcessingError,
			&i.ItemOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPodcastWithItems = `-- name: GetPodcastWithItems :one
SELECT 
    podcasts.id, podcasts.user_id, podcasts.title, podcasts.description, podcasts.status, podcasts.audio_url, podcasts.dialogues, podcasts.duration_seconds, podcasts.created_at, podcasts.updated_at, podcasts.completed_at,
    COALESCE(jsonb_agg(
        jsonb_build_object(
            'id', items.id,
            'title', items.title,
            'url', items.url,
            'summary', items.summary,
            'item_order', podcast_items.item_order
        ) ORDER BY podcast_items.item_order
    ) FILTER (WHERE items.id IS NOT NULL), '[]'::jsonb) as items
FROM podcasts
LEFT JOIN podcast_items ON podcasts.id = podcast_items.podcast_id
LEFT JOIN items ON podcast_items.item_id = items.id
WHERE podcasts.id = $1
GROUP BY podcasts.id
`

type GetPodcastWithItemsRow struct {
	ID              int32            `json:"id"`
	UserID          *int32           `json:"user_id"`
	Title           string           `json:"title"`
	Description     *string          `json:"description"`
	Status          string           `json:"status"`
	AudioUrl        *string          `json:"audio_url"`
	Dialogues       []byte           `json:"dialogues"`
	DurationSeconds *int32           `json:"duration_seconds"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	CompletedAt     pgtype.Timestamp `json:"completed_at"`
	Items           interface{}      `json:"items"`
}

func (q *Queries) GetPodcastWithItems(ctx context.Context, id int32) (GetPodcastWithItemsRow, error) {
	row := q.db.QueryRow(ctx, getPodcastWithItems, id)
	var i GetPodcastWithItemsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.AudioUrl,
		&i.Dialogues,
		&i.DurationSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.Items,
	)
	return i, err
}

const getPodcastsByStatus = `-- name: GetPodcastsByStatus :many
SELECT id, user_id, title, description, status, audio_url, dialogues, duration_seconds, created_at, updated_at, completed_at FROM podcasts WHERE status = $1 ORDER BY created_at DESC
`

func (q *Queries) GetPodcastsByStatus(ctx context.Context, status string) ([]Podcast, error) {
	rows, err := q.db.Query(ctx, getPodcastsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Podcast{}
	for rows.Next() {
		var i Podcast
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.AudioUrl,
			&i.Dialogues,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPodcastsByUserAndStatus = `-- name: GetPodcastsByUserAndStatus :many
SELECT id, user_id, title, description, status, audio_url, dialogues, duration_seconds, created_at, updated_at, completed_at FROM podcasts WHERE user_id = $1 AND status = $2 ORDER BY created_at DESC
`

type GetPodcastsByUserAndStatusParams struct {
	UserID *int32 `json:"user_id"`
	Status string `json:"status"`
}

func (q *Queries) GetPodcastsByUserAndStatus(ctx context.Context, arg GetPodcastsByUserAndStatusParams) ([]Podcast, error) {
	rows, err := q.db.Query(ctx, getPodcastsByUserAndStatus, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Podcast{}
	for rows.Next() {
		var i Podcast
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.AudioUrl,
			&i.Dialogues,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPodcastsForItem = `-- name: GetPodcastsForItem :many
SELECT podcasts.id, podcasts.user_id, podcasts.title, podcasts.description, podcasts.status, podcasts.audio_url, podcasts.dialogues, podcasts.duration_seconds, podcasts.created_at, podcasts.updated_at, podcasts.completed_at 
FROM podcasts 
JOIN podcast_items ON podcasts.id = podcast_items.podcast_id 
WHERE podcast_items.item_id = $1 
ORDER BY podcasts.created_at DESC
`

func (q *Queries) GetPodcastsForItem(ctx context.Context, itemID *int32) ([]Podcast, error) {
	rows, err := q.db.Query(ctx, getPodcastsForItem, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Podcast{}
	for rows.Next() {
		var i Podcast
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.AudioUrl,
			&i.Dialogues,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessingPodcasts = `-- name: GetProcessingPodcasts :many
SELECT id, user_id, title, description, status, audio_url, dialogues, duration_seconds, created_at, updated_at, completed_at FROM podcasts WHERE status = 'processing' ORDER BY created_at ASC LIMIT $1
`

func (q *Queries) GetProcessingPodcasts(ctx context.Context, limit int32) ([]Podcast, error) {
	rows, err := q.db.Query(ctx, getProcessingPodcasts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Podcast{}
	for rows.Next() {
		var i Podcast
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.AudioUrl,
			&i.Dialogues,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentPodcasts = `-- name: GetRecentPodcasts :many
SELECT id, user_id, title, description, status, audio_url, dialogues, duration_seconds, created_at, updated_at, completed_at FROM podcasts WHERE status = 'completed' AND created_at > NOW() - INTERVAL '7 days' ORDER BY created_at DESC LIMIT $1
`

func (q *Queries) GetRecentPodcasts(ctx context.Context, limit int32) ([]Podcast, error) {
	rows, err := q.db.Query(ctx, getRecentPodcasts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Podcast{}
	for rows.Next() {
		var i Podcast
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.AudioUrl,
			&i.Dialogues,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPodcastStats = `-- name: GetUserPodcastStats :one
SELECT 
    COUNT(*) as total_podcasts,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_podcasts,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_podcasts,
    COUNT(CASE WHEN status = 'processing' THEN 1 END) as processing_podcasts,
    COUNT(CASE WHEN status = 'writing' THEN 1 END) as writing_podcasts,
    COUNT(CASE WHEN created_at > NOW() - INTERVAL '7 days' THEN 1 END) as recent_podcasts
FROM podcasts 
WHERE user_id = $1
`

type GetUserPodcastStatsRow struct {
	TotalPodcasts      int64 `json:"total_podcasts"`
	CompletedPodcasts  int64 `json:"completed_podcasts"`
	PendingPodcasts    int64 `json:"pending_podcasts"`
	ProcessingPodcasts int64 `json:"processing_podcasts"`
	WritingPodcasts    int64 `json:"writing_podcasts"`
	RecentPodcasts     int64 `json:"recent_podcasts"`
}

func (q *Queries) GetUserPodcastStats(ctx context.Context, userID *int32) (GetUserPodcastStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserPodcastStats, userID)
	var i GetUserPodcastStatsRow
	err := row.Scan(
		&i.TotalPodcasts,
		&i.CompletedPodcasts,
		&i.PendingPodcasts,
		&i.ProcessingPodcasts,
		&i.WritingPodcasts,
		&i.RecentPodcasts,
	)
	return i, err
}

const removeItemFromPodcast = `-- name: RemoveItemFromPodcast :exec
DELETE FROM podcast_items WHERE podcast_id = $1 AND item_id = $2
`

type RemoveItemFromPodcastParams struct {
	PodcastID *int32 `json:"podcast_id"`
	ItemID    *int32 `json:"item_id"`
}

func (q *Queries) RemoveItemFromPodcast(ctx context.Context, arg RemoveItemFromPodcastParams) error {
	_, err := q.db.Exec(ctx, removeItemFromPodcast, arg.PodcastID, arg.ItemID)
	return err
}

const updatePodcast = `-- name: UpdatePodcast :exec
UPDATE podcasts SET title = $2, description = $3, updated_at = CURRENT_TIMESTAMP WHERE id = $1
`

type UpdatePodcastParams struct {
	ID          int32   `json:"id"`
	Title       string  `json:"title"`
	Description *string `json:"description"`
}

func (q *Queries) UpdatePodcast(ctx context.Context, arg UpdatePodcastParams) error {
	_, err := q.db.Exec(ctx, updatePodcast, arg.ID, arg.Title, arg.Description)
	return err
}

const updatePodcastAudio = `-- name: UpdatePodcastAudio :exec
UPDATE podcasts SET audio_url = $2, duration_seconds = $3, updated_at = CURRENT_TIMESTAMP WHERE id = $1
`

type UpdatePodcastAudioParams struct {
	ID              int32   `json:"id"`
	AudioUrl        *string `json:"audio_url"`
	DurationSeconds *int32  `json:"duration_seconds"`
}

func (q *Queries) UpdatePodcastAudio(ctx context.Context, arg UpdatePodcastAudioParams) error {
	_, err := q.db.Exec(ctx, updatePodcastAudio, arg.ID, arg.AudioUrl, arg.DurationSeconds)
	return err
}

const updatePodcastDialogues = `-- name: UpdatePodcastDialogues :exec
UPDATE podcasts SET dialogues = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $1
`

type UpdatePodcastDialoguesParams struct {
	ID        int32  `json:"id"`
	Dialogues []byte `json:"dialogues"`
}

func (q *Queries) UpdatePodcastDialogues(ctx context.Context, arg UpdatePodcastDialoguesParams) error {
	_, err := q.db.Exec(ctx, updatePodcastDialogues, arg.ID, arg.Dialogues)
	return err
}

const updatePodcastItemOrder = `-- name: UpdatePodcastItemOrder :exec
UPDATE podcast_items SET item_order = $3 WHERE podcast_id = $1 AND item_id = $2
`

type UpdatePodcastItemOrderParams struct {
	PodcastID *int32 `json:"podcast_id"`
	ItemID    *int32 `json:"item_id"`
	ItemOrder int32  `json:"item_order"`
}

func (q *Queries) UpdatePodcastItemOrder(ctx context.Context, arg UpdatePodcastItemOrderParams) error {
	_, err := q.db.Exec(ctx, updatePodcastItemOrder, arg.PodcastID, arg.ItemID, arg.ItemOrder)
	return err
}

const updatePodcastStatus = `-- name: UpdatePodcastStatus :exec
UPDATE podcasts SET status = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $1
`

type UpdatePodcastStatusParams struct {
	ID     int32  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdatePodcastStatus(ctx context.Context, arg UpdatePodcastStatusParams) error {
	_, err := q.db.Exec(ctx, updatePodcastStatus, arg.ID, arg.Status)
	return err
}

const updatePodcastStatusWithAudio = `-- name: UpdatePodcastStatusWithAudio :exec
UPDATE podcasts SET status = $2, audio_url = $3, duration_seconds = $4, completed_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP WHERE id = $1
`

type UpdatePodcastStatusWithAudioParams struct {
	ID              int32   `json:"id"`
	Status          string  `json:"status"`
	AudioUrl        *string `json:"audio_url"`
	DurationSeconds *int32  `json:"duration_seconds"`
}

func (q *Queries) UpdatePodcastStatusWithAudio(ctx context.Context, arg UpdatePodcastStatusWithAudioParams) error {
	_, err := q.db.Exec(ctx, updatePodcastStatusWithAudio,
		arg.ID,
		arg.Status,
		arg.AudioUrl,
		arg.DurationSeconds,
	)
	return err
}

const updatePodcastsStatus = `-- name: UpdatePodcastsStatus :exec
UPDATE podcasts SET status = $2, updated_at = CURRENT_TIMESTAMP WHERE id = ANY($1::int[])
`

type UpdatePodcastsStatusParams struct {
	Column1 []int32 `json:"column_1"`
	Status  string  `json:"status"`
}

func (q *Queries) UpdatePodcastsStatus(ctx context.Context, arg UpdatePodcastsStatusParams) error {
	_, err := q.db.Exec(ctx, updatePodcastsStatus, arg.Column1, arg.Status)
	return err
}
