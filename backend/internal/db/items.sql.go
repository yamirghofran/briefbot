// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: items.sql

package db

import (
	"context"
)

const createItem = `-- name: CreateItem :one
INSERT INTO items (user_id, title, url, text_content, summary, type, tags, platform, authors, processing_status, processing_error) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id, user_id, url, is_read, text_content, summary, type, tags, platform, authors, created_at, modified_at, title, processing_status, processing_error
`

type CreateItemParams struct {
	UserID           *int32   `json:"user_id"`
	Title            string   `json:"title"`
	Url              *string  `json:"url"`
	TextContent      *string  `json:"text_content"`
	Summary          *string  `json:"summary"`
	Type             *string  `json:"type"`
	Tags             []string `json:"tags"`
	Platform         *string  `json:"platform"`
	Authors          []string `json:"authors"`
	ProcessingStatus *string  `json:"processing_status"`
	ProcessingError  *string  `json:"processing_error"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Item, error) {
	row := q.db.QueryRow(ctx, createItem,
		arg.UserID,
		arg.Title,
		arg.Url,
		arg.TextContent,
		arg.Summary,
		arg.Type,
		arg.Tags,
		arg.Platform,
		arg.Authors,
		arg.ProcessingStatus,
		arg.ProcessingError,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.IsRead,
		&i.TextContent,
		&i.Summary,
		&i.Type,
		&i.Tags,
		&i.Platform,
		&i.Authors,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.Title,
		&i.ProcessingStatus,
		&i.ProcessingError,
	)
	return i, err
}

const createPendingItem = `-- name: CreatePendingItem :one
INSERT INTO items (user_id, title, url, processing_status) VALUES ($1, $2, $3, 'pending') RETURNING id, user_id, url, is_read, text_content, summary, type, tags, platform, authors, created_at, modified_at, title, processing_status, processing_error
`

type CreatePendingItemParams struct {
	UserID *int32  `json:"user_id"`
	Title  string  `json:"title"`
	Url    *string `json:"url"`
}

func (q *Queries) CreatePendingItem(ctx context.Context, arg CreatePendingItemParams) (Item, error) {
	row := q.db.QueryRow(ctx, createPendingItem, arg.UserID, arg.Title, arg.Url)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.IsRead,
		&i.TextContent,
		&i.Summary,
		&i.Type,
		&i.Tags,
		&i.Platform,
		&i.Authors,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.Title,
		&i.ProcessingStatus,
		&i.ProcessingError,
	)
	return i, err
}

const deleteItem = `-- name: DeleteItem :exec
DELETE FROM items WHERE id = $1
`

func (q *Queries) DeleteItem(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteItem, id)
	return err
}

const getFailedItemsForRetry = `-- name: GetFailedItemsForRetry :many
SELECT id, user_id, url, is_read, text_content, summary, type, tags, platform, authors, created_at, modified_at, title, processing_status, processing_error FROM items WHERE processing_status = 'failed' AND created_at > NOW() - INTERVAL '24 hours' ORDER BY created_at ASC LIMIT $1
`

func (q *Queries) GetFailedItemsForRetry(ctx context.Context, limit int32) ([]Item, error) {
	rows, err := q.db.Query(ctx, getFailedItemsForRetry, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Item{}
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.IsRead,
			&i.TextContent,
			&i.Summary,
			&i.Type,
			&i.Tags,
			&i.Platform,
			&i.Authors,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.Title,
			&i.ProcessingStatus,
			&i.ProcessingError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItem = `-- name: GetItem :one
SELECT id, user_id, url, is_read, text_content, summary, type, tags, platform, authors, created_at, modified_at, title, processing_status, processing_error FROM items WHERE id = $1
`

func (q *Queries) GetItem(ctx context.Context, id int32) (Item, error) {
	row := q.db.QueryRow(ctx, getItem, id)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.IsRead,
		&i.TextContent,
		&i.Summary,
		&i.Type,
		&i.Tags,
		&i.Platform,
		&i.Authors,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.Title,
		&i.ProcessingStatus,
		&i.ProcessingError,
	)
	return i, err
}

const getItemsByProcessingStatus = `-- name: GetItemsByProcessingStatus :many
SELECT id, user_id, url, is_read, text_content, summary, type, tags, platform, authors, created_at, modified_at, title, processing_status, processing_error FROM items WHERE processing_status = $1 ORDER BY created_at DESC
`

func (q *Queries) GetItemsByProcessingStatus(ctx context.Context, processingStatus *string) ([]Item, error) {
	rows, err := q.db.Query(ctx, getItemsByProcessingStatus, processingStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Item{}
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.IsRead,
			&i.TextContent,
			&i.Summary,
			&i.Type,
			&i.Tags,
			&i.Platform,
			&i.Authors,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.Title,
			&i.ProcessingStatus,
			&i.ProcessingError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemsByUser = `-- name: GetItemsByUser :many
SELECT id, user_id, url, is_read, text_content, summary, type, tags, platform, authors, created_at, modified_at, title, processing_status, processing_error FROM items WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetItemsByUser(ctx context.Context, userID *int32) ([]Item, error) {
	rows, err := q.db.Query(ctx, getItemsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Item{}
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.IsRead,
			&i.TextContent,
			&i.Summary,
			&i.Type,
			&i.Tags,
			&i.Platform,
			&i.Authors,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.Title,
			&i.ProcessingStatus,
			&i.ProcessingError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingItems = `-- name: GetPendingItems :many
SELECT id, user_id, url, is_read, text_content, summary, type, tags, platform, authors, created_at, modified_at, title, processing_status, processing_error FROM items WHERE processing_status = 'pending' ORDER BY created_at ASC LIMIT $1
`

func (q *Queries) GetPendingItems(ctx context.Context, limit int32) ([]Item, error) {
	rows, err := q.db.Query(ctx, getPendingItems, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Item{}
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.IsRead,
			&i.TextContent,
			&i.Summary,
			&i.Type,
			&i.Tags,
			&i.Platform,
			&i.Authors,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.Title,
			&i.ProcessingStatus,
			&i.ProcessingError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadItemsByUser = `-- name: GetUnreadItemsByUser :many
SELECT id, user_id, url, is_read, text_content, summary, type, tags, platform, authors, created_at, modified_at, title, processing_status, processing_error FROM items WHERE user_id = $1 AND is_read = FALSE ORDER BY created_at DESC
`

func (q *Queries) GetUnreadItemsByUser(ctx context.Context, userID *int32) ([]Item, error) {
	rows, err := q.db.Query(ctx, getUnreadItemsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Item{}
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.IsRead,
			&i.TextContent,
			&i.Summary,
			&i.Type,
			&i.Tags,
			&i.Platform,
			&i.Authors,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.Title,
			&i.ProcessingStatus,
			&i.ProcessingError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadItemsFromPreviousDay = `-- name: GetUnreadItemsFromPreviousDay :many
SELECT id, user_id, url, is_read, text_content, summary, type, tags, platform, authors, created_at, modified_at, title, processing_status, processing_error FROM items 
WHERE created_at >= DATE_TRUNC('day', NOW() - INTERVAL '1 day') 
  AND created_at < DATE_TRUNC('day', NOW())
  AND is_read = FALSE
  AND processing_status = 'completed'
ORDER BY created_at DESC
`

func (q *Queries) GetUnreadItemsFromPreviousDay(ctx context.Context) ([]Item, error) {
	rows, err := q.db.Query(ctx, getUnreadItemsFromPreviousDay)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Item{}
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.IsRead,
			&i.TextContent,
			&i.Summary,
			&i.Type,
			&i.Tags,
			&i.Platform,
			&i.Authors,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.Title,
			&i.ProcessingStatus,
			&i.ProcessingError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadItemsFromPreviousDayByUser = `-- name: GetUnreadItemsFromPreviousDayByUser :many
SELECT id, user_id, url, is_read, text_content, summary, type, tags, platform, authors, created_at, modified_at, title, processing_status, processing_error FROM items 
WHERE user_id = $1
  AND created_at >= DATE_TRUNC('day', NOW() - INTERVAL '1 day') 
  AND created_at < DATE_TRUNC('day', NOW())
  AND is_read = FALSE
  AND processing_status = 'completed'
ORDER BY created_at DESC
`

func (q *Queries) GetUnreadItemsFromPreviousDayByUser(ctx context.Context, userID *int32) ([]Item, error) {
	rows, err := q.db.Query(ctx, getUnreadItemsFromPreviousDayByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Item{}
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.IsRead,
			&i.TextContent,
			&i.Summary,
			&i.Type,
			&i.Tags,
			&i.Platform,
			&i.Authors,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.Title,
			&i.ProcessingStatus,
			&i.ProcessingError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markItemAsRead = `-- name: MarkItemAsRead :exec
UPDATE items SET is_read = TRUE, modified_at = CURRENT_TIMESTAMP WHERE id = $1
`

func (q *Queries) MarkItemAsRead(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, markItemAsRead, id)
	return err
}

const toggleItemReadStatus = `-- name: ToggleItemReadStatus :one
UPDATE items SET is_read = NOT is_read, modified_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id, user_id, url, is_read, text_content, summary, type, tags, platform, authors, created_at, modified_at, title, processing_status, processing_error
`

func (q *Queries) ToggleItemReadStatus(ctx context.Context, id int32) (Item, error) {
	row := q.db.QueryRow(ctx, toggleItemReadStatus, id)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.IsRead,
		&i.TextContent,
		&i.Summary,
		&i.Type,
		&i.Tags,
		&i.Platform,
		&i.Authors,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.Title,
		&i.ProcessingStatus,
		&i.ProcessingError,
	)
	return i, err
}

const updateItem = `-- name: UpdateItem :exec
UPDATE items SET title = $2, url = $3, is_read = $4, text_content = $5, summary = $6, type = $7, tags = $8, platform = $9, authors = $10, modified_at = CURRENT_TIMESTAMP WHERE id = $1
`

type UpdateItemParams struct {
	ID          int32    `json:"id"`
	Title       string   `json:"title"`
	Url         *string  `json:"url"`
	IsRead      *bool    `json:"is_read"`
	TextContent *string  `json:"text_content"`
	Summary     *string  `json:"summary"`
	Type        *string  `json:"type"`
	Tags        []string `json:"tags"`
	Platform    *string  `json:"platform"`
	Authors     []string `json:"authors"`
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) error {
	_, err := q.db.Exec(ctx, updateItem,
		arg.ID,
		arg.Title,
		arg.Url,
		arg.IsRead,
		arg.TextContent,
		arg.Summary,
		arg.Type,
		arg.Tags,
		arg.Platform,
		arg.Authors,
	)
	return err
}

const updateItemAsProcessing = `-- name: UpdateItemAsProcessing :exec
UPDATE items SET processing_status = 'processing', modified_at = CURRENT_TIMESTAMP WHERE id = $1
`

func (q *Queries) UpdateItemAsProcessing(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateItemAsProcessing, id)
	return err
}

const updateItemProcessingStatus = `-- name: UpdateItemProcessingStatus :exec
UPDATE items SET processing_status = $2, processing_error = $3, modified_at = CURRENT_TIMESTAMP WHERE id = $1
`

type UpdateItemProcessingStatusParams struct {
	ID               int32   `json:"id"`
	ProcessingStatus *string `json:"processing_status"`
	ProcessingError  *string `json:"processing_error"`
}

func (q *Queries) UpdateItemProcessingStatus(ctx context.Context, arg UpdateItemProcessingStatusParams) error {
	_, err := q.db.Exec(ctx, updateItemProcessingStatus, arg.ID, arg.ProcessingStatus, arg.ProcessingError)
	return err
}
